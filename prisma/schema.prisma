// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String                      @id @default(cuid())
  createdAt         DateTime                    @default(now())
  updatedAt         DateTime                    @updatedAt
  username          String                      @unique
  eblid             String?                     @unique
  email             String?                     @unique
  phone             String?                     @unique
  displayName       String?
  bio               String?
  avatarUrl         String?
  passwordHash      String
  status            UserStatus                  @default(OFFLINE)
  lastSeenAt        DateTime?
  contactsRequested Contact[]                   @relation("ContactRequester")
  contactsReceived  Contact[]                   @relation("ContactAddressee")
  conversations     ConversationParticipant[]
  conversationsCreated Conversation[]          @relation("ConversationCreator")
  messages          Message[]
  messageReactions  MessageReaction[]
  messageReceipts   MessageReceipt[]
  tokens            RefreshToken[]
  callSessions      CallSession[]               @relation("CallSessionInitiator")
  callParticipations CallParticipant[]
  devices           UserDevice[]
  availabilityIntervals ConversationAvailabilityInterval[]
  availabilityProposalsCreated ConversationAvailabilityProposal[] @relation("AvailabilityProposalCreator")
  availabilityProposalReactions ConversationAvailabilityProposalReaction[]
}

model Contact {
  id            String           @id @default(cuid())
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  requesterId   String
  addresseeId   String
  status        ContactStatus    @default(PENDING)
  requester     User             @relation("ContactRequester", fields: [requesterId], references: [id])
  addressee     User             @relation("ContactAddressee", fields: [addresseeId], references: [id])

  @@unique([requesterId, addresseeId])
  @@index([addresseeId, status])
  @@index([requesterId, status])
}

model Conversation {
  id             String                    @id @default(cuid())
  createdAt      DateTime                  @default(now())
  updatedAt      DateTime                  @updatedAt
  /// Conversation storage/encryption mode
  type           ConversationType          @default(CLOUD)
  title          String?
  avatarUrl      String?
  isGroup        Boolean                   @default(false)
  /// Marks a conversation as secret (ephemeral 1:1 chats, end-to-end friendly)
  isSecret       Boolean                   @default(false)
  /// Wrapped per-conversation DEK (base64) for server-side encryption in NON-secret chats
  nonSecretDekWrapped String?              @db.Text
  /// Optional message TTL in seconds for secret conversations; null means use default
  secretTtlSeconds Int?
  secretStatus   SecretConversationStatus  @default(ACTIVE)
  secretInitiatorDeviceId String?
  secretPeerDeviceId String?
  lastMessageAt  DateTime?
  createdById    String?
  createdBy      User?                     @relation("ConversationCreator", fields: [createdById], references: [id])
  participants   ConversationParticipant[]
  messages       Message[]
  callSessions   CallSession[]
  availabilityIntervals ConversationAvailabilityInterval[]
  availabilityProposals ConversationAvailabilityProposal[]
}

enum ConversationType {
  CLOUD
  SECRET
}

model ConversationParticipant {
  id             String                 @id @default(cuid())
  conversationId String
  userId         String
  role           ConversationRole       @default(MEMBER)
  joinedAt       DateTime               @default(now())
  mutedUntil     DateTime?
  conversation   Conversation           @relation(fields: [conversationId], references: [id])
  user           User                   @relation(fields: [userId], references: [id])

  @@unique([conversationId, userId])
  @@index([userId])
}

model ConversationAvailabilityInterval {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  conversationId String
  userId         String
  startUtc       DateTime
  endUtc         DateTime
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([conversationId, userId])
  @@index([conversationId, startUtc])
  @@unique([conversationId, userId, startUtc, endUtc])
}

enum AvailabilityProposalReactionValue {
  YES
  MAYBE
  NO
}

model ConversationAvailabilityProposal {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  conversationId String
  createdById    String
  note           String?
  /// Max end time of all ranges for filtering expired proposals
  maxEndUtc      DateTime
  deletedAt      DateTime?

  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  createdBy      User         @relation("AvailabilityProposalCreator", fields: [createdById], references: [id], onDelete: Cascade)
  intervals      ConversationAvailabilityProposalInterval[]
  reactions      ConversationAvailabilityProposalReaction[]

  @@index([conversationId, maxEndUtc])
  @@index([conversationId, createdAt])
  @@index([createdById, createdAt])
}

model ConversationAvailabilityProposalInterval {
  id         String       @id @default(cuid())
  proposalId String
  startUtc   DateTime
  endUtc     DateTime
  proposal   ConversationAvailabilityProposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)

  @@index([proposalId, startUtc])
  @@unique([proposalId, startUtc, endUtc])
}

model ConversationAvailabilityProposalReaction {
  id         String       @id @default(cuid())
  proposalId String
  userId     String
  value      AvailabilityProposalReactionValue
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  proposal   ConversationAvailabilityProposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  user       User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([proposalId, userId])
  @@index([userId, createdAt])
}

model Message {
  id             String          @id @default(cuid())
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  conversationId String
  senderId       String
  type           MessageType     @default(TEXT)
  content        String?
  /// 0 = plaintext, 1 = encrypted (non-secret chats server-side encryption)
  contentEncV    Int             @default(0)
  metadata       Json?
  replyToId      String?
  replyTo        Message?        @relation("MessageReplies", fields: [replyToId], references: [id])
  replies        Message[]        @relation("MessageReplies")
  deletedAt      DateTime?
  /// Optional expiration time (for secret/ephemeral messages)
  expiresAt      DateTime?
  conversation   Conversation    @relation(fields: [conversationId], references: [id])
  sender         User            @relation(fields: [senderId], references: [id])
  attachments    MessageAttachment[]
  reactions      MessageReaction[]
  receipts       MessageReceipt[]

  @@index([conversationId, createdAt])
  @@index([conversationId, contentEncV])
  @@index([replyToId])
}

model MessageAttachment {
  id        String          @id @default(cuid())
  createdAt DateTime        @default(now())
  messageId String
  url       String
  type      AttachmentType
  size      Int?
  metadata  Json?
  message   Message         @relation(fields: [messageId], references: [id])

  @@index([messageId])
}

model MessageReaction {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  messageId String
  userId    String
  emoji     String
  message   Message  @relation(fields: [messageId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([messageId, userId, emoji])
}

model MessageReceipt {
  id        String        @id @default(cuid())
  createdAt DateTime      @default(now())
  messageId String
  userId    String
  status    ReceiptStatus @default(DELIVERED)
  message   Message       @relation(fields: [messageId], references: [id])
  user      User          @relation(fields: [userId], references: [id])

  @@unique([messageId, userId])
  @@index([userId, status])
}

model RefreshToken {
  id        String    @id @default(cuid())
  token     String    @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime  @default(now())
  revokedAt DateTime?
  user      User      @relation(fields: [userId], references: [id])

  @@index([userId])
}

model CallSession {
  id              String        @id @default(cuid())
  startedAt       DateTime      @default(now())
  endedAt         DateTime?
  conversationId  String
  initiatorId     String
  roomName        String
  type            CallType      @default(VOICE)
  conversation    Conversation  @relation(fields: [conversationId], references: [id])
  initiator       User          @relation("CallSessionInitiator", fields: [initiatorId], references: [id])
  participants    CallParticipant[]

  @@index([conversationId])
}

model CallParticipant {
  id        String      @id @default(cuid())
  sessionId String
  userId    String
  joinedAt  DateTime    @default(now())
  leftAt    DateTime?
  session   CallSession @relation(fields: [sessionId], references: [id])
  user      User        @relation(fields: [userId], references: [id])

  @@unique([sessionId, userId])
  @@index([userId])
}

enum UserStatus {
  ONLINE
  OFFLINE
  AWAY
  DND
  BACKGROUND
  IN_CALL
}

enum ContactStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

enum ConversationRole {
  MEMBER
  ADMIN
  OWNER
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  FILE
  SYSTEM
  CALL
}

enum AttachmentType {
  IMAGE
  VIDEO
  AUDIO
  FILE
}

enum ReceiptStatus {
  DELIVERED
  READ
  SEEN
}

enum CallType {
  VOICE
  VIDEO
}

model UserDevice {
  id                  String        @id
  userId              String
  name                String
  platform            String?
  publicKey           String
  identityPublicKey   String?
  signedPreKeyId      String?
  signedPreKeyPublic  String?
  signedPreKeySignature String?
  signedPreKeyExpiresAt DateTime?
  keyVersion          Int           @default(1)
  keyAlg              String        @default("x25519+ed25519")
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
  lastSeenAt          DateTime?
  revokedAt           DateTime?
  user                User          @relation(fields: [userId], references: [id])
  prekeys             DevicePrekey[]

  @@index([userId])
}

model DevicePrekey {
  id                String      @id @default(cuid())
  deviceId          String
  keyId             String
  publicKey         String
  oneTimePreKeyId   String?
  oneTimePreKeyPublic String?
  version           Int         @default(1)
  alg               String      @default("x25519")
  createdAt         DateTime    @default(now())
  consumedAt        DateTime?
  device            UserDevice  @relation(fields: [deviceId], references: [id], onDelete: Cascade)

  @@unique([deviceId, keyId])
  @@index([deviceId, consumedAt])
}

enum SecretConversationStatus {
  ACTIVE
  PENDING
  CANCELLED
}

/// Durable ciphertext storage for SECRET threads + per-device delivery.
/// Source of truth is Postgres; Redis is only an inbox/cache accelerator.
model SecretMessage {
  msgId          String   @id @default(uuid()) @map("msgId")
  threadId       String?  @map("threadId")
  senderUserId   String   @map("senderUserId")
  senderDeviceId String?  @map("senderDeviceId")
  createdAt      DateTime @default(now()) @map("createdAt")
  headerJson     Json     @map("headerJson")
  ciphertextBlob Bytes    @map("ciphertextBlob")
  contentType    String   @map("contentType")
  schemaVersion  Int      @default(1) @map("schemaVersion")

  deliveries     SecretDelivery[]

  @@index([threadId, createdAt])
  @@index([senderUserId, createdAt])
  @@map("messages_secret")
}

enum SecretDeliveryStatus {
  PENDING
  DELIVERED
  READ
}

model SecretDelivery {
  msgId            String              @map("msgId")
  receiverDeviceId String              @map("receiverDeviceId")
  status           SecretDeliveryStatus @default(PENDING) @map("status")
  deliveredAt      DateTime?           @map("deliveredAt")
  readAt           DateTime?           @map("readAt")

  message          SecretMessage        @relation(fields: [msgId], references: [msgId], onDelete: Cascade)

  @@id([msgId, receiverDeviceId])
  @@index([receiverDeviceId, status])
  @@map("deliveries_secret")
}

/// Metadata-only refs for ciphertext attachments in SECRET threads.
/// No plaintext keys/content are stored server-side.
model SecretAttachmentRef {
  id          String   @id @default(cuid())
  threadId    String   @map("threadId")
  objectKey   String   @map("objectKey")
  ownerUserId String   @map("ownerUserId")
  createdAt   DateTime @default(now()) @map("createdAt")
  expiresAt   DateTime? @map("expiresAt")
  deletedAt   DateTime? @map("deletedAt")

  @@unique([threadId, objectKey])
  @@index([threadId, deletedAt])
  @@index([ownerUserId, deletedAt])
  @@index([expiresAt, deletedAt])
  @@map("secret_attachment_refs")
}

/// One-time pairing token for linking a new device to an existing trusted device.
model DevicePairing {
  token            String    @id
  userId           String
  newDeviceId      String
  code             String
  createdAt        DateTime  @default(now())
  expiresAt        DateTime
  consumedAt       DateTime?
  consumedByDeviceId String?

  @@index([userId, expiresAt])
  @@index([newDeviceId, expiresAt])
  @@map("device_pairings")
}
