import * as s from "react";
import { useRef as ae, useMemo as Ne, useCallback as ee, useEffect as _e } from "react";
import { u as U, r as Fe, a as Pe, b as xe, c as Q, d as Ue, e as He, f as oe, g as Ve, h as qe, i as ue, j as Be, k as je, m as ze, G as We, n as Ge, o as Je, p as le, q as $e, t as Qe, v as Le, w as de, x as Ae, y as Ke, l as V, z as Ye, A as Xe, B as fe, C as Ze, D as et, E as tt, F as nt, H as st, I as rt, J as ot, K as at, M as ve, N as ct, O as it, P as ut, Q as lt, S as dt, T as ft, U as mt, V as pt, W as Re, X as ht, Y as bt, Z as gt, _ as vt, $ as St, a0 as yt, a1 as Ct, a2 as Mt, a3 as Tt, a4 as Et, a5 as kt, a6 as wt, a7 as ie, a8 as W, a9 as Pt, aa as Lt, ab as At, ac as Rt, ad as Dt } from "./contexts-CsO1QZ3r.mjs";
import { m as G } from "./room-Bb6uLxS5.mjs";
import { ConnectionState as I, LocalTrackPublication as Ot, facingModeFromLocalTrack as It, Room as De, Track as E, createAudioAnalyser as me, ParticipantKind as se, Mutex as Nt, ParticipantEvent as X, RoomEvent as H, decodeTokenPayload as _t, TokenSourceConfigurable as Ft } from "livekit-client";
const xt = (e) => {
  const n = s.useRef(e);
  return s.useEffect(() => {
    n.current = e;
  }), n;
};
function Ut(e, n) {
  const t = Vt(), r = xt(n);
  return s.useLayoutEffect(() => {
    let o = !1;
    const c = e.current;
    if (!c) return;
    function a(i, u) {
      o || r.current(i, u);
    }
    return t == null || t.subscribe(c, a), () => {
      o = !0, t == null || t.unsubscribe(c, a);
    };
  }, [e.current, t, r]), t == null ? void 0 : t.observer;
}
function Ht() {
  let e = !1, n = [];
  const t = /* @__PURE__ */ new Map();
  if (typeof window > "u")
    return;
  const r = new ResizeObserver((o, c) => {
    n = n.concat(o), e || window.requestAnimationFrame(() => {
      const a = /* @__PURE__ */ new Set();
      for (let i = 0; i < n.length; i++) {
        if (a.has(n[i].target)) continue;
        a.add(n[i].target);
        const u = t.get(n[i].target);
        u == null || u.forEach((p) => p(n[i], c));
      }
      n = [], e = !1;
    }), e = !0;
  });
  return {
    observer: r,
    subscribe(o, c) {
      r.observe(o);
      const a = t.get(o) ?? [];
      a.push(c), t.set(o, a);
    },
    unsubscribe(o, c) {
      const a = t.get(o) ?? [];
      if (a.length === 1) {
        r.unobserve(o), t.delete(o);
        return;
      }
      const i = a.indexOf(c);
      i !== -1 && a.splice(i, 1), t.set(o, a);
    }
  };
}
let ce;
const Vt = () => ce || (ce = Ht()), qt = (e) => {
  const [n, t] = s.useState({ width: 0, height: 0 });
  s.useLayoutEffect(() => {
    if (e.current) {
      const { width: o, height: c } = e.current.getBoundingClientRect();
      t({ width: o, height: c });
    }
  }, [e.current]);
  const r = s.useCallback(
    (o) => t(o.contentRect),
    []
  );
  return Ut(e, r), n;
};
function D(e, n, t = !0) {
  const [r, o] = s.useState(n);
  return s.useEffect(() => {
    if (t && o(n), typeof window > "u" || !e) return;
    const c = e.subscribe(o);
    return () => c.unsubscribe();
  }, [e, t]), r;
}
function kn(e) {
  const n = (c) => typeof window < "u" ? window.matchMedia(c).matches : !1, [t, r] = s.useState(n(e));
  function o() {
    r(n(e));
  }
  return s.useEffect(() => {
    const c = window.matchMedia(e);
    return o(), c.addListener ? c.addListener(o) : c.addEventListener("change", o), () => {
      c.removeListener ? c.removeListener(o) : c.removeEventListener("change", o);
    };
  }, [e]), t;
}
function wn(e) {
  const n = U(e), t = s.useCallback(async () => {
    await n.startAudio();
  }, [n]), r = s.useMemo(
    () => Fe(n),
    [n]
  ), { canPlayAudio: o } = D(r, {
    canPlayAudio: n.canPlaybackAudio
  });
  return { canPlayAudio: o, startAudio: t };
}
function Pn(e) {
  const { state: n, dispatch: t } = Pe().pin;
  return { buttonProps: s.useMemo(() => {
    const { className: o } = xe();
    return G(e, {
      className: o,
      disabled: !(n != null && n.length),
      onClick: () => {
        t && t({ msg: "clear_pin" });
      }
    });
  }, [e, t, n]) };
}
function Ln(e = {}) {
  const n = Q(e.participant), { className: t, connectionQualityObserver: r } = s.useMemo(
    () => Ue(n),
    [n]
  ), o = D(r, n.connectionQuality);
  return { className: t, quality: o };
}
function te(e) {
  const n = U(e), t = s.useMemo(() => He(n), [n]);
  return D(t, n.state);
}
function An(e, n) {
  const t = typeof e == "function" ? e : n, r = typeof e == "string" ? e : void 0, o = oe(), { send: c, messageObservable: a, isSendingObservable: i } = s.useMemo(
    () => Ve(o, r, t),
    [o, r, t]
  ), u = D(a, void 0), p = D(i, !1);
  return {
    message: u,
    send: c,
    isSending: p
  };
}
function Rn(e) {
  const n = oe(), t = te(n);
  return { buttonProps: s.useMemo(() => {
    const { className: o, disconnect: c } = qe(n);
    return G(e, {
      className: o,
      onClick: () => c(e.stopTracks ?? !0),
      disabled: t === I.Disconnected
    });
  }, [n, e, t]) };
}
function Bt(e) {
  if (e.publication instanceof Ot) {
    const n = e.publication.track;
    if (n) {
      const { facingMode: t } = It(n);
      return t;
    }
  }
  return "undefined";
}
function Dn({ trackRef: e, props: n }) {
  const t = ue(e), r = Be(), { className: o } = s.useMemo(() => je(), []), c = s.useMemo(() => ze(t, r == null ? void 0 : r.pin.state), [t, r == null ? void 0 : r.pin.state]);
  return { mergedProps: s.useMemo(
    () => G(n, {
      className: o,
      onClick: (i) => {
        var u, p, h, d, l;
        (u = n.onClick) == null || u.call(n, i), c ? (h = r == null ? void 0 : (p = r.pin).dispatch) == null || h.call(p, {
          msg: "clear_pin"
        }) : (l = r == null ? void 0 : (d = r.pin).dispatch) == null || l.call(d, {
          msg: "set_pin",
          trackReference: t
        });
      }
    }),
    [n, o, t, c, r == null ? void 0 : r.pin]
  ), inFocus: c };
}
function On(e, n, t = {}) {
  const r = t.gridLayouts ?? We, { width: o, height: c } = qt(e), a = Ge(r, n, o, c);
  return s.useEffect(() => {
    e.current && a && (e.current.style.setProperty("--lk-col-count", a == null ? void 0 : a.columns.toString()), e.current.style.setProperty("--lk-row-count", a == null ? void 0 : a.rows.toString()));
  }, [e, a]), {
    layout: a,
    containerWidth: o,
    containerHeight: c
  };
}
function Se(e, n = {}) {
  var i, u;
  const t = typeof e == "string" ? n.participant : e.participant, r = Q(t), o = typeof e == "string" ? { participant: r, source: e } : e, [c, a] = s.useState(
    !!((i = o.publication) != null && i.isMuted || (u = r.getTrackPublication(o.source)) != null && u.isMuted)
  );
  return s.useEffect(() => {
    const p = Je(o).subscribe(a);
    return () => p.unsubscribe();
  }, [le(o)]), c;
}
function jt(e) {
  const n = Q(e), t = s.useMemo(() => $e(n), [n]);
  return D(t, n.isSpeaking);
}
function Oe(e = {}) {
  const n = U(e.room), [t, r] = s.useState(n.localParticipant), [o, c] = s.useState(
    t.isMicrophoneEnabled
  ), [a, i] = s.useState(t.isCameraEnabled), [u, p] = s.useState(
    t.isScreenShareEnabled
  ), [h, d] = s.useState(
    t.lastMicrophoneError
  ), [l, v] = s.useState(t.lastCameraError), [C, k] = s.useState(
    void 0
  ), [A, w] = s.useState(void 0), O = (R) => {
    i(R.isCameraEnabled), c(R.isMicrophoneEnabled), p(R.isScreenShareEnabled), w(R.cameraTrack), k(R.microphoneTrack), d(R.participant.lastMicrophoneError), v(R.participant.lastCameraError), r(R.participant);
  };
  return s.useEffect(() => {
    const R = Qe(n.localParticipant).subscribe(O);
    return () => R.unsubscribe();
  }, [n]), {
    isMicrophoneEnabled: o,
    isScreenShareEnabled: u,
    isCameraEnabled: a,
    microphoneTrack: C,
    cameraTrack: A,
    lastMicrophoneError: h,
    lastCameraError: l,
    localParticipant: t
  };
}
function In() {
  const e = oe(), n = s.useMemo(
    () => Le(e.localParticipant),
    [e]
  );
  return D(n, e.localParticipant.permissions);
}
function Nn({
  kind: e,
  room: n,
  track: t,
  requestPermissions: r,
  onError: o
}) {
  const c = de(), a = s.useMemo(() => n ?? c ?? new De(), [n, c]), i = s.useMemo(
    () => Ae(e, o, r),
    [e, r, o]
  ), u = D(i, []), [p, h] = s.useState(
    (a == null ? void 0 : a.getActiveDevice(e)) ?? "default"
  ), { className: d, activeDeviceObservable: l, setActiveMediaDevice: v } = s.useMemo(
    () => Ke(e, a),
    [e, a, t]
  );
  return s.useEffect(() => {
    const C = l.subscribe((k) => {
      k && (V.info("setCurrentDeviceId", k), h(k));
    });
    return () => {
      C == null || C.unsubscribe();
    };
  }, [l]), { devices: u, className: d, activeDeviceId: p, setActiveMediaDevice: v };
}
function _n({
  kind: e,
  onError: n
}) {
  const t = s.useMemo(
    () => Ae(e, n),
    [e, n]
  );
  return D(t, []);
}
function zt(e, n, t = {}) {
  const r = s.useRef([]), o = s.useRef(-1), c = n !== o.current, a = typeof t.customSortFunction == "function" ? t.customSortFunction(e) : Ye(e);
  let i = [...a];
  if (c === !1)
    try {
      i = Xe(r.current, a, n);
    } catch (u) {
      V.error("Error while running updatePages(): ", u);
    }
  return c ? r.current = a : r.current = i, o.current = n, i;
}
function Fn(e, n) {
  const [t, r] = s.useState(1), o = Math.max(Math.ceil(n.length / e), 1);
  t > o && r(o);
  const c = t * e, a = c - e, i = (d) => {
    r((l) => d === "next" ? l === o ? l : l + 1 : l === 1 ? l : l - 1);
  }, u = (d) => {
    d > o ? r(o) : d < 1 ? r(1) : r(d);
  }, h = zt(n, e).slice(a, c);
  return {
    totalPageCount: o,
    nextPage: () => i("next"),
    prevPage: () => i("previous"),
    setPage: u,
    firstItemIndex: a,
    lastItemIndex: c,
    tracks: h,
    currentPage: t
  };
}
function xn(e = {}) {
  let n = fe();
  e.participant && (n = e.participant);
  const t = s.useMemo(() => Ze(n), [n]), { identity: r, name: o, metadata: c } = D(t, {
    name: n == null ? void 0 : n.name,
    identity: n == null ? void 0 : n.identity,
    metadata: n == null ? void 0 : n.metadata
  });
  return { identity: r, name: o, metadata: c };
}
function Un(e = {}) {
  const n = Q(e.participant), t = s.useMemo(() => Le(n), [n]);
  return D(t, n.permissions);
}
function Hn({
  trackRef: e,
  onParticipantClick: n,
  disableSpeakingIndicator: t,
  htmlProps: r
}) {
  const o = ue(e), c = s.useMemo(() => {
    const { className: l } = et();
    return G(r, {
      className: l,
      onClick: (v) => {
        var C;
        if ((C = r.onClick) == null || C.call(r, v), typeof n == "function") {
          const k = o.publication ?? o.participant.getTrackPublication(o.source);
          n({ participant: o.participant, track: k });
        }
      }
    });
  }, [
    r,
    n,
    o.publication,
    o.source,
    o.participant
  ]), a = o.participant.getTrackPublication(E.Source.Microphone), i = s.useMemo(() => ({
    participant: o.participant,
    source: E.Source.Microphone,
    publication: a
  }), [a, o.participant]), u = Se(o), p = Se(i), h = jt(o.participant), d = Bt(o);
  return {
    elementProps: {
      "data-lk-audio-muted": p,
      "data-lk-video-muted": u,
      "data-lk-speaking": t === !0 ? !1 : h,
      "data-lk-local-participant": o.participant.isLocal,
      "data-lk-source": o.source,
      "data-lk-facing-mode": d,
      ...c
    }
  };
}
function pe(e = {}) {
  const n = U(e.room), [t, r] = s.useState([]);
  return s.useEffect(() => {
    const o = tt(n, {
      additionalRoomEvents: e.updateOnlyOn
    }).subscribe(r);
    return () => o.unsubscribe();
  }, [n, JSON.stringify(e.updateOnlyOn)]), t;
}
function Wt(e = {}) {
  const n = pe(e), { localParticipant: t } = Oe(e);
  return s.useMemo(
    () => [t, ...n],
    [t, n]
  );
}
function Vn(e) {
  return e = nt(e), s.useMemo(() => (e == null ? void 0 : e.pin.state) !== void 0 && e.pin.state.length >= 1 ? e.pin.state : [], [e.pin.state]);
}
function qn(e, n = {}) {
  const t = oe(), [r] = s.useState(n.updateOnlyOn), o = s.useMemo(() => typeof e == "string" ? st(t, e, {
    additionalEvents: r
  }) : rt(t, e, {
    additionalEvents: r
  }), [t, JSON.stringify(e), r]), [c, a] = s.useState({
    p: void 0
  });
  return s.useEffect(() => {
    const i = o.subscribe((u) => a({ p: u }));
    return () => i.unsubscribe();
  }, [o]), c.p;
}
function Bn(e = {}) {
  const n = U(e.room), t = s.useMemo(() => ot(n), [n]), { name: r, metadata: o } = D(t, {
    name: n.name,
    metadata: n.metadata
  });
  return { name: r, metadata: o };
}
function Gt(e) {
  const n = U(e == null ? void 0 : e.room), t = s.useMemo(() => at(n), [n]);
  return D(t, n.activeSpeakers);
}
function jn(e) {
  const [n, t] = s.useState(
    ve(e)
  ), r = Gt();
  return s.useEffect(() => {
    t(ve(e));
  }, [r, e]), n;
}
function zn({ room: e, props: n }) {
  const t = U(e), { className: r, roomAudioPlaybackAllowedObservable: o, handleStartAudioPlayback: c } = s.useMemo(
    () => ct(),
    []
  ), a = s.useMemo(
    () => o(t),
    [t, o]
  ), { canPlayAudio: i } = D(a, {
    canPlayAudio: t.canPlaybackAudio
  });
  return { mergedProps: s.useMemo(
    () => G(n, {
      className: r,
      onClick: () => {
        c(t);
      },
      style: { display: i ? "none" : "block" }
    }),
    [n, r, i, c, t]
  ), canPlayAudio: i };
}
function Wn({ room: e, props: n }) {
  const t = U(e), { className: r, roomVideoPlaybackAllowedObservable: o, handleStartVideoPlayback: c } = s.useMemo(
    () => it(),
    []
  ), a = s.useMemo(
    () => o(t),
    [t, o]
  ), { canPlayVideo: i } = D(a, {
    canPlayVideo: t.canPlaybackVideo
  });
  return { mergedProps: s.useMemo(
    () => G(n, {
      className: r,
      onClick: () => {
        c(t);
      },
      style: { display: i ? "none" : "block" }
    }),
    [n, r, i, c, t]
  ), canPlayVideo: i };
}
function Gn(e, n = {}) {
  const t = s.useRef(null), r = s.useRef(null), o = n.minSwipeDistance ?? 50, c = (u) => {
    r.current = null, t.current = u.targetTouches[0].clientX;
  }, a = (u) => {
    r.current = u.targetTouches[0].clientX;
  }, i = s.useCallback(() => {
    if (!t.current || !r.current)
      return;
    const u = t.current - r.current, p = u > o, h = u < -o;
    p && n.onLeftSwipe && n.onLeftSwipe(), h && n.onRightSwipe && n.onRightSwipe();
  }, [o, n]);
  s.useEffect(() => {
    const u = e.current;
    return u && (u.addEventListener("touchstart", c, { passive: !0 }), u.addEventListener("touchmove", a, { passive: !0 }), u.addEventListener("touchend", i, { passive: !0 })), () => {
      u && (u.removeEventListener("touchstart", c), u.removeEventListener("touchmove", a), u.removeEventListener("touchend", i));
    };
  }, [e, i]);
}
function Jn({ props: e }) {
  const { dispatch: n, state: t } = Pe().widget, { className: r } = s.useMemo(() => ut(), []);
  return { mergedProps: s.useMemo(() => G(e, {
    className: r,
    onClick: () => {
      n && n({ msg: "toggle_chat" });
    },
    "aria-pressed": t != null && t.showChat ? "true" : "false",
    "data-lk-unread-msgs": t ? t.unreadMessages < 10 ? t.unreadMessages.toFixed(0) : "9+" : "0"
  }), [e, r, n, t]) };
}
function $n(e, n, t = {}) {
  const [r, o] = s.useState(void 0);
  return s.useEffect(() => {
    var a;
    if (e === void 0)
      throw Error("token endpoint needs to be defined");
    if (((a = t.userInfo) == null ? void 0 : a.identity) === void 0)
      return;
    (async () => {
      V.debug("fetching token");
      const i = new URLSearchParams({ ...t.userInfo, roomName: n }), u = await fetch(`${e}?${i.toString()}`);
      if (!u.ok) {
        V.error(
          `Could not fetch token. Server responded with status ${u.status}: ${u.statusText}`
        );
        return;
      }
      const { accessToken: p } = await u.json();
      o(p);
    })();
  }, [e, n, JSON.stringify(t)]), r;
}
function Qn(e) {
  var c, a;
  const n = ue(e), { className: t, mediaMutedObserver: r } = s.useMemo(
    () => lt(n),
    [le(n)]
  );
  return { isMuted: D(
    r,
    !!((c = n.publication) != null && c.isMuted || (a = n.participant.getTrackPublication(n.source)) != null && a.isMuted)
  ), className: t };
}
function Kn({
  source: e,
  onChange: n,
  initialState: t,
  captureOptions: r,
  publishOptions: o,
  onDeviceError: c,
  room: a,
  ...i
}) {
  var m;
  const u = de(), p = s.useMemo(() => a ?? u, [a, u]), h = (m = p == null ? void 0 : p.localParticipant) == null ? void 0 : m.getTrackPublication(e), d = s.useRef(!1), { toggle: l, className: v, pendingObserver: C, enabledObserver: k } = s.useMemo(
    () => p ? dt(e, p, r, o, c) : ft(),
    [p, e, JSON.stringify(r), o]
  ), A = D(C, !1), w = D(k, t ?? !!(h != null && h.isEnabled));
  s.useEffect(() => {
    n == null || n(w, d.current), d.current = !1;
  }, [w, n]), s.useEffect(() => {
    t !== void 0 && (V.debug("forcing initial toggle state", e, t), l(t));
  }, []);
  const O = s.useMemo(() => G(i, { className: v }), [i, v]), R = s.useCallback(
    (f) => {
      var b;
      d.current = !0, l().catch(() => d.current = !1), (b = i.onClick) == null || b.call(i, f);
    },
    [i, l]
  );
  return {
    toggle: l,
    enabled: w,
    pending: A,
    track: h,
    buttonProps: {
      ...O,
      "aria-pressed": w,
      "data-lk-source": e,
      "data-lk-enabled": w,
      disabled: A,
      onClick: R
    }
  };
}
function Yn(e = [
  E.Source.Camera,
  E.Source.Microphone,
  E.Source.ScreenShare,
  E.Source.ScreenShareAudio,
  E.Source.Unknown
], n = {}) {
  const t = U(n.room), [r, o] = s.useState([]), [c, a] = s.useState([]), i = s.useMemo(() => e.map((p) => mt(p) ? p.source : p), [JSON.stringify(e)]);
  return s.useEffect(() => {
    const p = pt(t, i, {
      additionalRoomEvents: n.updateOnlyOn,
      onlySubscribed: n.onlySubscribed
    }).subscribe(({ trackReferences: h, participants: d }) => {
      V.debug("setting track bundles", h, d), o(h), a(d);
    });
    return () => p.unsubscribe();
  }, [
    t,
    JSON.stringify(n.onlySubscribed),
    JSON.stringify(n.updateOnlyOn),
    JSON.stringify(e)
  ]), s.useMemo(() => {
    if (Re(e)) {
      const p = $t(e, c), h = Array.from(r);
      return c.forEach((d) => {
        p.has(d.identity) && (p.get(d.identity) ?? []).forEach((v) => {
          if (r.find(
            ({ participant: k, publication: A }) => d.identity === k.identity && A.source === v
          ))
            return;
          V.debug(
            `Add ${v} placeholder for participant ${d.identity}.`
          );
          const C = {
            participant: d,
            source: v
          };
          h.push(C);
        });
      }), h;
    } else
      return r;
  }, [r, c, e]);
}
function Jt(e, n) {
  const t = new Set(e);
  for (const r of n)
    t.delete(r);
  return t;
}
function $t(e, n) {
  const t = /* @__PURE__ */ new Map();
  if (Re(e)) {
    const r = e.filter((o) => o.withPlaceholder).map((o) => o.source);
    n.forEach((o) => {
      const c = o.getTrackPublications().map((i) => {
        var u;
        return (u = i.track) == null ? void 0 : u.source;
      }).filter((i) => i !== void 0), a = Array.from(
        Jt(new Set(r), new Set(c))
      );
      a.length > 0 && t.set(o.identity, a);
    });
  }
  return t;
}
function Qt(e) {
  const [n, t] = s.useState(ht(e)), { trackObserver: r } = s.useMemo(() => bt(e), [e.participant.sid ?? e.participant.identity, e.source]);
  return s.useEffect(() => {
    const o = r.subscribe((c) => {
      t(c);
    });
    return () => o == null ? void 0 : o.unsubscribe();
  }, [r]), {
    participant: e.participant,
    source: e.source ?? E.Source.Unknown,
    publication: n
  };
}
function Xn(e, n) {
  const t = Q(n);
  return Qt({ name: e, participant: t });
}
function Kt(e) {
  const n = U(e == null ? void 0 : e.room), t = te(n), r = s.useMemo(
    () => t === I.Disconnected,
    [t]
  ), o = s.useMemo(
    () => gt(n, e),
    [n, e, r]
  ), c = D(o.isSendingObservable, !1), a = D(o.messageObservable, []);
  return { send: o.send, chatMessages: a, isSending: c };
}
function Zn(e = {}) {
  const [n, t] = s.useState(
    vt(e.defaults, e.preventLoad ?? !1)
  ), r = s.useCallback((u) => {
    t((p) => ({ ...p, audioEnabled: u }));
  }, []), o = s.useCallback((u) => {
    t((p) => ({ ...p, videoEnabled: u }));
  }, []), c = s.useCallback((u) => {
    t((p) => ({ ...p, audioDeviceId: u }));
  }, []), a = s.useCallback((u) => {
    t((p) => ({ ...p, videoDeviceId: u }));
  }, []), i = s.useCallback((u) => {
    t((p) => ({ ...p, username: u }));
  }, []);
  return s.useEffect(() => {
    St(n, e.preventSave ?? !1);
  }, [n, e.preventSave]), {
    userChoices: n,
    saveAudioInputEnabled: r,
    saveVideoInputEnabled: o,
    saveAudioInputDeviceId: c,
    saveVideoInputDeviceId: a,
    saveUsername: i
  };
}
function es(e, n = {}) {
  const t = Q(e), r = U(n.room), o = s.useMemo(() => yt(r, t), [r, t]);
  return D(
    o,
    t.isLocal ? t.isE2EEEnabled : !!(t != null && t.isEncrypted)
  );
}
function ts(e, n = { fftSize: 32, smoothingTimeConstant: 0 }) {
  const t = Ct(e) ? e.publication.track : e, [r, o] = s.useState(0);
  return s.useEffect(() => {
    if (!t || !t.mediaStream)
      return;
    const { cleanup: c, analyser: a } = me(t, n), i = a.frequencyBinCount, u = new Uint8Array(i), h = setInterval(() => {
      a.getByteFrequencyData(u);
      let d = 0;
      for (let l = 0; l < u.length; l++) {
        const v = u[l];
        d += v * v;
      }
      o(Math.sqrt(d / u.length) / 255);
    }, 1e3 / 30);
    return () => {
      c(), clearInterval(h);
    };
  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n)]), r;
}
const Yt = (e) => {
  const n = (t) => {
    let c = 1 - Math.max(-100, Math.min(-10, t)) * -1 / 100;
    return c = Math.sqrt(c), c;
  };
  return e.map((t) => t === -1 / 0 ? 0 : n(t));
}, Xt = {
  bands: 5,
  loPass: 100,
  hiPass: 600,
  updateInterval: 32,
  analyserOptions: { fftSize: 2048 }
};
function ns(e, n = {}) {
  var a;
  const t = e instanceof E ? e : (a = e == null ? void 0 : e.publication) == null ? void 0 : a.track, r = { ...Xt, ...n }, [o, c] = s.useState(
    new Array(r.bands).fill(0)
  );
  return s.useEffect(() => {
    if (!t || !(t != null && t.mediaStream)) {
      c((v) => v.slice().fill(0));
      return;
    }
    const { analyser: i, cleanup: u } = me(t, r.analyserOptions), p = i.frequencyBinCount, h = new Float32Array(p), l = setInterval(() => {
      i.getFloatFrequencyData(h);
      let v = new Float32Array(h.length);
      for (let w = 0; w < h.length; w++)
        v[w] = h[w];
      v = v.slice(n.loPass, n.hiPass);
      const C = Yt(v), k = Math.ceil(C.length / r.bands), A = [];
      for (let w = 0; w < r.bands; w++) {
        const O = C.slice(w * k, (w + 1) * k).reduce((R, m) => R += m, 0);
        A.push(O / k);
      }
      c(A);
    }, r.updateInterval);
    return () => {
      u(), clearInterval(l);
    };
  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n)]), o;
}
const Zt = {
  barCount: 120,
  volMultiplier: 5,
  updateInterval: 20
};
function ss(e, n = {}) {
  var h;
  const t = e instanceof E ? e : (h = e == null ? void 0 : e.publication) == null ? void 0 : h.track, r = { ...Zt, ...n }, o = s.useRef(new Float32Array()), c = s.useRef(performance.now()), a = s.useRef(0), [i, u] = s.useState([]), p = s.useCallback((d) => {
    u(
      Array.from(
        tn(d, r.barCount).map((l) => Math.sqrt(l) * r.volMultiplier)
        // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),
      )
    );
  }, []);
  return s.useEffect(() => {
    if (!t || !(t != null && t.mediaStream))
      return;
    const { analyser: d, cleanup: l } = me(t, {
      fftSize: ye(r.barCount)
    }), v = ye(r.barCount), C = new Float32Array(v), k = () => {
      if (A = requestAnimationFrame(k), d.getFloatTimeDomainData(C), o.current.map((w, O) => w + C[O]), a.current += 1, performance.now() - c.current >= r.updateInterval) {
        const w = C.map((O) => O / a.current);
        p(w), c.current = performance.now(), a.current = 0;
      }
    };
    let A = requestAnimationFrame(k);
    return () => {
      l(), cancelAnimationFrame(A);
    };
  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n), p]), {
    bars: i
  };
}
function ye(e) {
  return e < 32 ? 32 : en(e);
}
function en(e) {
  let n = 2;
  for (; e >>= 1; )
    n <<= 1;
  return n;
}
function tn(e, n) {
  const t = Math.floor(e.length / n), r = new Float32Array(n);
  for (let o = 0; o < n; o++) {
    const c = t * o;
    let a = 0;
    for (let i = 0; i < t; i++)
      a = a + Math.abs(e[c + i]);
    r[o] = a / t;
  }
  return r;
}
function re(e, n = {}) {
  let t, r;
  typeof n == "string" ? t = n : (t = n == null ? void 0 : n.participantIdentity, r = n == null ? void 0 : n.room);
  const o = fe(), c = Wt({ room: r, updateOnlyOn: [] }), a = s.useMemo(() => t ? c.find((p) => p.identity === t) : o, [t, c, o]), i = s.useMemo(() => {
    if (a)
      return Mt(a, { sources: e });
  }, [a, JSON.stringify(e)]);
  return D(i, []);
}
function nn(e) {
  var t, r, o;
  const n = s.useMemo(
    () => {
      var c;
      return (c = e == null ? void 0 : e.publication) != null && c.track ? Tt(e == null ? void 0 : e.publication.track) : void 0;
    },
    [(t = e == null ? void 0 : e.publication) == null ? void 0 : t.track]
  );
  return D(n, {
    timestamp: Date.now(),
    rtpTimestamp: (o = (r = e == null ? void 0 : e.publication) == null ? void 0 : r.track) == null ? void 0 : o.rtpTimestamp
  });
}
const sn = {
  bufferSize: 100
  // maxAge: 2_000,
};
function rn(e, n) {
  const t = { ...sn, ...n }, [r, o] = s.useState([]), c = nn(e), a = (i) => {
    var u;
    (u = t.onTranscription) == null || u.call(t, i), o(
      (p) => kt(
        p,
        // when first receiving a segment, add the current media timestamp to it
        i.map((h) => wt(h, c)),
        t.bufferSize
      )
    );
  };
  return s.useEffect(() => {
    if (!(e != null && e.publication))
      return;
    const i = Et(e.publication).subscribe((u) => {
      a(...u);
    });
    return () => {
      i.unsubscribe();
    };
  }, [e && le(e), a]), { segments: r };
}
function on(e = {}) {
  const n = fe(), t = e.participant ?? n, r = s.useMemo(
    // weird typescript constraint
    () => t ? ie(t) : ie(t),
    [t]
  );
  return D(r, {
    attributes: t == null ? void 0 : t.attributes
  });
}
function rs(e, n = {}) {
  const t = Q(n.participant), [r, o] = s.useState(t.attributes[e]);
  return s.useEffect(() => {
    if (!t)
      return;
    const c = ie(t).subscribe((a) => {
      a.changed[e] !== void 0 && o(a.attributes[e]);
    });
    return () => {
      c.unsubscribe();
    };
  }, [t, e]), r;
}
const Ce = W.AgentState;
function os() {
  const e = pe(), n = e.find(
    (d) => d.kind === se.AGENT && !(W.PublishOnBehalf in d.attributes)
  ), t = e.find(
    (d) => d.kind === se.AGENT && d.attributes[W.PublishOnBehalf] === (n == null ? void 0 : n.identity)
  ), r = re(
    [E.Source.Microphone, E.Source.Camera],
    n == null ? void 0 : n.identity
  ), o = re(
    [E.Source.Microphone, E.Source.Camera],
    t == null ? void 0 : t.identity
  ), c = r.find((d) => d.source === E.Source.Microphone) ?? o.find((d) => d.source === E.Source.Microphone), a = r.find((d) => d.source === E.Source.Camera) ?? o.find((d) => d.source === E.Source.Camera), { segments: i } = rn(c), u = te(), { attributes: p } = on({ participant: n }), h = s.useMemo(() => u === I.Disconnected ? "disconnected" : u === I.Connecting || !n || !(p != null && p[Ce]) ? "connecting" : p[Ce], [p, n, u]);
  return {
    agent: n,
    state: h,
    audioTrack: c,
    videoTrack: a,
    agentTranscriptions: i,
    agentAttributes: p
  };
}
function as(e) {
  const n = U(e), t = te(n), r = s.useMemo(() => Pt(n), [n, t]);
  return D(r, n.isRecording);
}
function an(e, n) {
  const t = U(n == null ? void 0 : n.room), o = te(t) === I.Disconnected, c = s.useMemo(() => Lt(t, e), [t, e]);
  return { textStreams: D(o ? void 0 : c, []) };
}
function cn(e) {
  const { participantIdentities: n, trackSids: t } = e ?? {}, { textStreams: r } = an(At.TRANSCRIPTION, { room: e == null ? void 0 : e.room });
  return s.useMemo(
    () => r.filter(
      (c) => n ? n.includes(c.participantInfo.identity) : !0
    ).filter(
      (c) => {
        var a;
        return t ? t.includes(
          ((a = c.streamInfo.attributes) == null ? void 0 : a[W.TranscribedTrackId]) ?? ""
        ) : !0;
      }
    ),
    [r, n, t]
  );
}
const Me = 2, Te = 400, Ee = 3, ke = 1e3;
function cs(e) {
  const n = ae([]), t = Ne(() => new Nt(), []), r = ee(async () => t.lock().then(async (h) => {
    for (; ; ) {
      const d = n.current.pop();
      if (!d) {
        h();
        break;
      }
      switch (d.type) {
        case "connect":
          await d.room.connect(...d.args).then(d.resolve).catch(d.reject);
          break;
        case "disconnect":
          await d.room.disconnect(...d.args).then(d.resolve).catch(d.reject);
          break;
      }
    }
  }), []), o = ae([]), c = ee((h) => {
    let d = 0;
    o.current = o.current.filter((l) => {
      const v = h.getTime() - l.getTime() < ke;
      return v && (d += 1), v;
    }), d > Ee && V.warn(
      `useSequentialRoomConnectDisconnect: room changed reference rapidly (over ${Ee}x in ${ke}ms). This is not recommended.`
    );
  }, []);
  _e(() => {
    n.current = [];
    const h = /* @__PURE__ */ new Date();
    o.current.push(h), c(h);
  }, [e, c]);
  const a = ae([]), i = ee((h) => {
    let d = 0;
    a.current = a.current.filter((l) => {
      const v = h.getTime() - l.getTime() < Te;
      return v && (d += 1), v;
    }), d > Me && V.warn(
      `useSequentialRoomConnectDisconnect: room connect / disconnect occurring in rapid sequence (over ${Me}x in ${Te}ms). This is not recommended and may be the sign of a bug like a useEffect dependency changing every render.`
    );
  }, []), u = ee(
    async (...h) => new Promise((d, l) => {
      if (!e)
        throw new Error("Called connect(), but room was unset");
      const v = /* @__PURE__ */ new Date();
      i(v), n.current.push({ type: "connect", room: e, args: h, resolve: d, reject: l }), a.current.push(v), r();
    }),
    [e, i, r]
  ), p = ee(
    async (...h) => new Promise((d, l) => {
      if (!e)
        throw new Error("Called discconnect(), but room was unset");
      const v = /* @__PURE__ */ new Date();
      i(v), n.current.push({ type: "disconnect", room: e, args: h, resolve: d, reject: l }), a.current.push(v), r();
    }),
    [e, i, r]
  );
  return {
    connect: e ? u : null,
    disconnect: e ? p : null
  };
}
var ne = { exports: {} }, we;
function un() {
  if (we) return ne.exports;
  we = 1;
  var e = typeof Reflect == "object" ? Reflect : null, n = e && typeof e.apply == "function" ? e.apply : function(f, b, g) {
    return Function.prototype.apply.call(f, b, g);
  }, t;
  e && typeof e.ownKeys == "function" ? t = e.ownKeys : Object.getOwnPropertySymbols ? t = function(f) {
    return Object.getOwnPropertyNames(f).concat(Object.getOwnPropertySymbols(f));
  } : t = function(f) {
    return Object.getOwnPropertyNames(f);
  };
  function r(m) {
    console && console.warn && console.warn(m);
  }
  var o = Number.isNaN || function(f) {
    return f !== f;
  };
  function c() {
    c.init.call(this);
  }
  ne.exports = c, ne.exports.once = w, c.EventEmitter = c, c.prototype._events = void 0, c.prototype._eventsCount = 0, c.prototype._maxListeners = void 0;
  var a = 10;
  function i(m) {
    if (typeof m != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof m);
  }
  Object.defineProperty(c, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return a;
    },
    set: function(m) {
      if (typeof m != "number" || m < 0 || o(m))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + m + ".");
      a = m;
    }
  }), c.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, c.prototype.setMaxListeners = function(f) {
    if (typeof f != "number" || f < 0 || o(f))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + f + ".");
    return this._maxListeners = f, this;
  };
  function u(m) {
    return m._maxListeners === void 0 ? c.defaultMaxListeners : m._maxListeners;
  }
  c.prototype.getMaxListeners = function() {
    return u(this);
  }, c.prototype.emit = function(f) {
    for (var b = [], g = 1; g < arguments.length; g++) b.push(arguments[g]);
    var y = f === "error", T = this._events;
    if (T !== void 0)
      y = y && T.error === void 0;
    else if (!y)
      return !1;
    if (y) {
      var M;
      if (b.length > 0 && (M = b[0]), M instanceof Error)
        throw M;
      var P = new Error("Unhandled error." + (M ? " (" + M.message + ")" : ""));
      throw P.context = M, P;
    }
    var F = T[f];
    if (F === void 0)
      return !1;
    if (typeof F == "function")
      n(F, this, b);
    else
      for (var q = F.length, J = C(F, q), g = 0; g < q; ++g)
        n(J[g], this, b);
    return !0;
  };
  function p(m, f, b, g) {
    var y, T, M;
    if (i(b), T = m._events, T === void 0 ? (T = m._events = /* @__PURE__ */ Object.create(null), m._eventsCount = 0) : (T.newListener !== void 0 && (m.emit(
      "newListener",
      f,
      b.listener ? b.listener : b
    ), T = m._events), M = T[f]), M === void 0)
      M = T[f] = b, ++m._eventsCount;
    else if (typeof M == "function" ? M = T[f] = g ? [b, M] : [M, b] : g ? M.unshift(b) : M.push(b), y = u(m), y > 0 && M.length > y && !M.warned) {
      M.warned = !0;
      var P = new Error("Possible EventEmitter memory leak detected. " + M.length + " " + String(f) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      P.name = "MaxListenersExceededWarning", P.emitter = m, P.type = f, P.count = M.length, r(P);
    }
    return m;
  }
  c.prototype.addListener = function(f, b) {
    return p(this, f, b, !1);
  }, c.prototype.on = c.prototype.addListener, c.prototype.prependListener = function(f, b) {
    return p(this, f, b, !0);
  };
  function h() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function d(m, f, b) {
    var g = { fired: !1, wrapFn: void 0, target: m, type: f, listener: b }, y = h.bind(g);
    return y.listener = b, g.wrapFn = y, y;
  }
  c.prototype.once = function(f, b) {
    return i(b), this.on(f, d(this, f, b)), this;
  }, c.prototype.prependOnceListener = function(f, b) {
    return i(b), this.prependListener(f, d(this, f, b)), this;
  }, c.prototype.removeListener = function(f, b) {
    var g, y, T, M, P;
    if (i(b), y = this._events, y === void 0)
      return this;
    if (g = y[f], g === void 0)
      return this;
    if (g === b || g.listener === b)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete y[f], y.removeListener && this.emit("removeListener", f, g.listener || b));
    else if (typeof g != "function") {
      for (T = -1, M = g.length - 1; M >= 0; M--)
        if (g[M] === b || g[M].listener === b) {
          P = g[M].listener, T = M;
          break;
        }
      if (T < 0)
        return this;
      T === 0 ? g.shift() : k(g, T), g.length === 1 && (y[f] = g[0]), y.removeListener !== void 0 && this.emit("removeListener", f, P || b);
    }
    return this;
  }, c.prototype.off = c.prototype.removeListener, c.prototype.removeAllListeners = function(f) {
    var b, g, y;
    if (g = this._events, g === void 0)
      return this;
    if (g.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : g[f] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete g[f]), this;
    if (arguments.length === 0) {
      var T = Object.keys(g), M;
      for (y = 0; y < T.length; ++y)
        M = T[y], M !== "removeListener" && this.removeAllListeners(M);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (b = g[f], typeof b == "function")
      this.removeListener(f, b);
    else if (b !== void 0)
      for (y = b.length - 1; y >= 0; y--)
        this.removeListener(f, b[y]);
    return this;
  };
  function l(m, f, b) {
    var g = m._events;
    if (g === void 0)
      return [];
    var y = g[f];
    return y === void 0 ? [] : typeof y == "function" ? b ? [y.listener || y] : [y] : b ? A(y) : C(y, y.length);
  }
  c.prototype.listeners = function(f) {
    return l(this, f, !0);
  }, c.prototype.rawListeners = function(f) {
    return l(this, f, !1);
  }, c.listenerCount = function(m, f) {
    return typeof m.listenerCount == "function" ? m.listenerCount(f) : v.call(m, f);
  }, c.prototype.listenerCount = v;
  function v(m) {
    var f = this._events;
    if (f !== void 0) {
      var b = f[m];
      if (typeof b == "function")
        return 1;
      if (b !== void 0)
        return b.length;
    }
    return 0;
  }
  c.prototype.eventNames = function() {
    return this._eventsCount > 0 ? t(this._events) : [];
  };
  function C(m, f) {
    for (var b = new Array(f), g = 0; g < f; ++g)
      b[g] = m[g];
    return b;
  }
  function k(m, f) {
    for (; f + 1 < m.length; f++)
      m[f] = m[f + 1];
    m.pop();
  }
  function A(m) {
    for (var f = new Array(m.length), b = 0; b < f.length; ++b)
      f[b] = m[b].listener || m[b];
    return f;
  }
  function w(m, f) {
    return new Promise(function(b, g) {
      function y(M) {
        m.removeListener(f, T), g(M);
      }
      function T() {
        typeof m.removeListener == "function" && m.removeListener("error", y), b([].slice.call(arguments));
      }
      R(m, f, T, { once: !0 }), f !== "error" && O(m, y, { once: !0 });
    });
  }
  function O(m, f, b) {
    typeof m.on == "function" && R(m, "error", f, b);
  }
  function R(m, f, b, g) {
    if (typeof m.on == "function")
      g.once ? m.once(f, b) : m.on(f, b);
    else if (typeof m.addEventListener == "function")
      m.addEventListener(f, function y(T) {
        g.once && m.removeEventListener(f, y), b(T);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof m);
  }
  return ne.exports;
}
var he = un();
const ln = 2e4;
var dn = /* @__PURE__ */ ((e) => (e.CameraChanged = "cameraChanged", e.MicrophoneChanged = "microphoneChanged", e.StateChanged = "stateChanged", e))(dn || {});
const x = (e) => ({
  isConnected: e === "listening" || e === "thinking" || e === "speaking",
  canListen: e === "pre-connect-buffering" || e === "listening" || e === "thinking" || e === "speaking",
  isFinished: e === "disconnected" || e === "failed",
  isPending: e === "connecting" || e === "initializing" || e === "idle"
}), fn = () => {
  const [e, n] = s.useState(
    null
  ), [t, r] = s.useState(
    null
  ), o = s.useRef("connecting"), c = s.useRef(!1), a = (i) => setTimeout(() => {
    if (!c.current) {
      n("Agent did not join the room.");
      return;
    }
    const { isConnected: u } = x(o.current);
    if (!u) {
      n("Agent joined the room but did not complete initializing.");
      return;
    }
  }, i ?? ln);
  return {
    agentTimeoutFailureReason: e,
    startAgentTimeout: s.useCallback(
      (i) => {
        t && clearTimeout(t), n(null), r(a(i)), o.current = "connecting", c.current = !1;
      },
      [t]
    ),
    clearAgentTimeout: s.useCallback(() => {
      t && clearTimeout(t), n(null), r(null), o.current = "connecting", c.current = !1;
    }, [t]),
    clearAgentTimeoutFailureReason: s.useCallback(() => {
      n(null);
    }, []),
    updateAgentTimeoutState: s.useCallback((i) => {
      o.current = i;
    }, []),
    updateAgentTimeoutParticipantExists: s.useCallback((i) => {
      c.current = i;
    }, [])
  };
};
function mn(e, n) {
  const t = s.useRef(n);
  s.useEffect(() => {
    t.current = n;
  }, [n]);
  const r = s.useCallback(
    async (a) => {
      const { isConnected: i } = x(t.current);
      if (!i)
        return new Promise((u, p) => {
          const h = (v) => {
            const { isConnected: C } = x(v);
            C && (l(), u());
          }, d = () => {
            l(), p(new Error("useAgent(/* ... */).waitUntilConnected - signal aborted"));
          }, l = () => {
            e.off("stateChanged", h), a == null || a.removeEventListener("abort", d);
          };
          e.on("stateChanged", h), a == null || a.addEventListener("abort", d);
        });
    },
    [e]
  ), o = s.useCallback(
    async (a) => {
      const { canListen: i } = x(t.current);
      if (!i)
        return new Promise((u, p) => {
          const h = (v) => {
            const { canListen: C } = x(v);
            C && (l(), u());
          }, d = () => {
            l(), p(new Error("useAgent(/* ... */).waitUntilCouldBeListening - signal aborted"));
          }, l = () => {
            e.off("stateChanged", h), a == null || a.removeEventListener("abort", d);
          };
          e.on("stateChanged", h), a == null || a.addEventListener("abort", d);
        });
    },
    [e]
  ), c = s.useCallback(
    async (a) => {
      const { isFinished: i } = x(t.current);
      if (!i)
        return new Promise((u, p) => {
          const h = (v) => {
            const { isFinished: C } = x(v);
            C && (l(), u());
          }, d = () => {
            l(), p(new Error("useAgent(/* ... */).waitUntilFinished - signal aborted"));
          }, l = () => {
            e.off("stateChanged", h), a == null || a.removeEventListener("abort", d);
          };
          e.on("stateChanged", h), a == null || a.addEventListener("abort", d);
        });
    },
    [e]
  );
  return { waitUntilConnected: r, waitUntilCouldBeListening: o, waitUntilFinished: c };
}
function Ie(e) {
  const n = Rt();
  if (e = e ?? n, !e)
    throw new Error(
      "No session provided, make sure you are inside a Session context or pass the session explicitly"
    );
  const {
    room: t,
    internal: {
      agentConnectTimeoutMilliseconds: r,
      agentTimeoutFailureReason: o,
      startAgentTimeout: c,
      clearAgentTimeout: a,
      clearAgentTimeoutFailureReason: i,
      updateAgentTimeoutState: u,
      updateAgentTimeoutParticipantExists: p
    }
  } = e, h = s.useMemo(() => new he.EventEmitter(), []), d = pe({ room: t }), l = s.useMemo(() => d.find(
    (S) => S.kind === se.AGENT && !(W.PublishOnBehalf in S.attributes)
  ) ?? null, [d]), v = s.useMemo(() => l ? d.find(
    (S) => S.kind === se.AGENT && S.attributes[W.PublishOnBehalf] === l.identity
  ) ?? null : null, [l, d]), [C, k] = s.useState({});
  s.useEffect(() => {
    if (!l)
      return;
    const S = (_) => {
      k(_);
    };
    return l.on(X.AttributesChanged, S), () => {
      l.off(X.AttributesChanged, S);
    };
  }, [l, h]);
  const A = re([E.Source.Camera, E.Source.Microphone], {
    room: t,
    participantIdentity: l == null ? void 0 : l.identity
  }), w = re([E.Source.Camera, E.Source.Microphone], {
    room: t,
    participantIdentity: v == null ? void 0 : v.identity
  }), O = s.useMemo(
    () => A.find((S) => S.source === E.Source.Camera) ?? w.find((S) => S.source === E.Source.Camera),
    [A, w]
  );
  s.useEffect(() => {
    h.emit("cameraChanged", O);
  }, [h, O]);
  const R = s.useMemo(
    () => A.find((S) => S.source === E.Source.Microphone) ?? w.find((S) => S.source === E.Source.Microphone),
    [A, w]
  );
  s.useEffect(() => {
    h.emit("microphoneChanged", R);
  }, [h, R]);
  const [m, f] = s.useState(t.state);
  s.useEffect(() => {
    const S = (_) => {
      f(_);
    };
    return t.on(H.ConnectionStateChanged, S), () => {
      t.off(H.ConnectionStateChanged, S);
    };
  }, [t]), s.useEffect(() => {
    l && i();
  }, [l]);
  const [b, g] = s.useState(null);
  s.useEffect(() => {
    if (!l)
      return;
    const S = (_) => {
      _.identity === (l == null ? void 0 : l.identity) && g("Agent left the room unexpectedly.");
    };
    return t.on(H.ParticipantDisconnected, S), () => {
      t.off(H.ParticipantDisconnected, S);
    };
  }, [l, t]), s.useEffect(() => {
    m === I.Disconnected && g(null);
  }, [m]);
  const [y, T] = s.useState(
    () => t.localParticipant.getTrackPublication(E.Source.Microphone) ?? null
  );
  s.useEffect(() => {
    const S = () => {
      T(t.localParticipant.getTrackPublication(E.Source.Microphone) ?? null);
    }, _ = () => {
      T(null);
    };
    return t.localParticipant.on(
      X.LocalTrackPublished,
      S
    ), t.localParticipant.on(
      X.LocalTrackUnpublished,
      _
    ), () => {
      t.localParticipant.off(
        X.LocalTrackPublished,
        S
      ), t.localParticipant.off(
        X.LocalTrackUnpublished,
        _
      );
    };
  }, [t.localParticipant]);
  const M = s.useMemo(() => {
    const S = [];
    return o && S.push(o), b && S.push(b), S;
  }, [o, b]), P = s.useMemo(() => {
    if (M.length > 0)
      return "failed";
    let S = "disconnected";
    return m !== I.Disconnected && (S = "connecting"), y && (S = "pre-connect-buffering"), l && C[W.AgentState] && (S = C[W.AgentState]), S;
  }, [
    M,
    m,
    y,
    l,
    C
  ]);
  s.useEffect(() => {
    h.emit("stateChanged", P), u(P);
  }, [h, P]), s.useEffect(() => {
    p(l !== null);
  }, [l]);
  const F = e.connectionState === "disconnected";
  s.useEffect(() => {
    if (!F)
      return c(r), () => {
        a();
      };
  }, [F, r]);
  const q = s.useMemo(() => {
    const S = {
      attributes: C,
      internal: {
        agentParticipant: l,
        workerParticipant: v,
        emitter: h
      }
    };
    switch (P) {
      case "disconnected":
        return {
          ...S,
          state: P,
          ...x(P),
          failureReasons: null,
          // Clear inner values if no longer connected
          cameraTrack: void 0,
          microphoneTrack: void 0
        };
      case "connecting":
        return {
          ...S,
          state: P,
          ...x(P),
          failureReasons: null,
          // Clear inner values if no longer connected
          cameraTrack: void 0,
          microphoneTrack: void 0
        };
      case "initializing":
      case "idle":
        return {
          ...S,
          state: P,
          ...x(P),
          failureReasons: null,
          cameraTrack: O,
          microphoneTrack: R
        };
      case "pre-connect-buffering":
        return {
          ...S,
          state: P,
          ...x(P),
          failureReasons: null,
          cameraTrack: O,
          microphoneTrack: R
        };
      case "listening":
      case "thinking":
      case "speaking":
        return {
          ...S,
          state: P,
          ...x(P),
          failureReasons: null,
          cameraTrack: O,
          microphoneTrack: R
        };
      case "failed":
        return {
          ...S,
          state: "failed",
          ...x("failed"),
          failureReasons: M,
          // Clear inner values if no longer connected
          cameraTrack: void 0,
          microphoneTrack: void 0
        };
    }
  }, [C, h, l, P, O, R]), { waitUntilConnected: J, waitUntilCouldBeListening: K, waitUntilFinished: L } = mn(h, P), N = s.useCallback(
    (S) => new Promise((_, Y) => {
      const B = (z) => {
        z && ($(), _(z));
      }, j = () => {
        $(), Y(new Error("useAgent(/* ... */).waitUntilCamera - signal aborted"));
      }, $ = () => {
        h.off("cameraChanged", B), S == null || S.removeEventListener("abort", j);
      };
      h.on("cameraChanged", B), S == null || S.addEventListener("abort", j);
    }),
    [h]
  ), Z = s.useCallback(
    (S) => new Promise((_, Y) => {
      const B = (z) => {
        z && ($(), _(z));
      }, j = () => {
        $(), Y(new Error("useAgent(/* ... */).waitUntilMicrophone - signal aborted"));
      }, $ = () => {
        h.off("microphoneChanged", B), S == null || S.removeEventListener("abort", j);
      };
      h.on("microphoneChanged", B), S == null || S.addEventListener("abort", j);
    }),
    [h]
  );
  return s.useMemo(() => ({
    ...q,
    waitUntilConnected: J,
    waitUntilCouldBeListening: K,
    waitUntilFinished: L,
    waitUntilCamera: N,
    waitUntilMicrophone: Z
  }), [
    q,
    J,
    K,
    L,
    N,
    Z
  ]);
}
var pn = /* @__PURE__ */ ((e) => (e.ConnectionStateChanged = "connectionStateChanged", e.MediaDevicesError = "mediaDevicesError", e.EncryptionError = "encryptionError", e))(pn || {});
function hn(e, n) {
  const t = /* @__PURE__ */ new Set([...Object.keys(e), ...Object.keys(n)]);
  for (const r of t)
    switch (r) {
      case "roomName":
      case "participantName":
      case "participantIdentity":
      case "participantMetadata":
      case "participantAttributes":
      case "agentName":
      case "agentMetadata":
        if (e[r] !== n[r])
          return !1;
        break;
      default:
        const o = r;
        throw new Error(`Options key ${o} not being checked for equality!`);
    }
  return !0;
}
function bn(e, n) {
  const t = s.useRef(n);
  return s.useEffect(() => {
    t.current = n;
  }, [n]), s.useCallback(
    async (o, c) => {
      if (t.current !== o)
        return new Promise((a, i) => {
          const u = (d) => {
            d === o && (h(), a());
          }, p = () => {
            h(), i(
              new Error(
                `useSession(/* ... */).waitUntilConnectionState(${o}, /* signal */) - signal aborted`
              )
            );
          }, h = () => {
            e.off("connectionStateChanged", u), c == null || c.removeEventListener("abort", p);
          };
          e.on("connectionStateChanged", u), c == null || c.addEventListener("abort", p);
        });
    },
    [e]
  );
}
function gn(e, n) {
  const t = e instanceof Ft, r = s.useRef(
    t ? n : null
  );
  return s.useEffect(() => {
    if (!t) {
      r.current = null;
      return;
    }
    r.current !== null && hn(r.current, n) || (r.current = n);
  }, [t, n]), s.useCallback(async () => {
    if (t) {
      if (!r.current)
        throw new Error(
          "AgentSession - memoized token fetch options are not set, but the passed tokenSource was an instance of TokenSourceConfigurable. If you are seeing this please make a new GitHub issue!"
        );
      return e.fetch(r.current);
    } else
      return e.fetch();
  }, [t, e]);
}
function is(e, n = {}) {
  const { room: t, agentConnectTimeoutMilliseconds: r, ...o } = n, c = de(), a = s.useMemo(
    () => c ?? t ?? new De(),
    [c, t]
  ), i = s.useMemo(
    () => new he.EventEmitter(),
    []
  ), u = s.useCallback(
    (L) => ({
      isConnected: L === I.Connected || L === I.Reconnecting || L === I.SignalReconnecting
    }),
    []
  ), [p, h] = s.useState(a.state);
  s.useEffect(() => {
    const L = (N) => {
      h(N);
    };
    return a.on(H.ConnectionStateChanged, L), () => {
      a.off(H.ConnectionStateChanged, L);
    };
  }, [a]), s.useEffect(() => {
    const L = async (N) => {
      i.emit("mediaDevicesError", N);
    };
    return a.on(H.MediaDevicesError, L), () => {
      a.off(H.MediaDevicesError, L);
    };
  }, [a, i]), s.useEffect(() => {
    const L = async (N) => {
      i.emit("encryptionError", N);
    };
    return a.on(H.EncryptionError, L), () => {
      a.off(H.EncryptionError, L);
    };
  }, [a, i]);
  const { localParticipant: d } = Oe({ room: a }), l = d.getTrackPublication(E.Source.Camera), v = s.useMemo(() => !l || l.isMuted ? null : {
    source: E.Source.Camera,
    participant: d,
    publication: l
  }, [d, l, l == null ? void 0 : l.isMuted]), C = d.getTrackPublication(E.Source.Microphone), k = s.useMemo(() => !C || C.isMuted ? null : {
    source: E.Source.Microphone,
    participant: d,
    publication: C
  }, [d, C, C == null ? void 0 : C.isMuted]), {
    agentTimeoutFailureReason: A,
    startAgentTimeout: w,
    clearAgentTimeout: O,
    clearAgentTimeoutFailureReason: R,
    updateAgentTimeoutState: m,
    updateAgentTimeoutParticipantExists: f
  } = fn(), b = s.useMemo(
    () => ({
      emitter: i,
      tokenSource: e,
      agentConnectTimeoutMilliseconds: r,
      agentTimeoutFailureReason: A,
      startAgentTimeout: w,
      clearAgentTimeout: O,
      clearAgentTimeoutFailureReason: R,
      updateAgentTimeoutState: m,
      updateAgentTimeoutParticipantExists: f
    }),
    [
      i,
      r,
      e,
      A,
      w,
      O,
      R,
      m,
      f
    ]
  ), g = s.useMemo(() => {
    const L = {
      room: a,
      internal: b
    };
    switch (p) {
      case I.Connecting:
        return {
          ...L,
          connectionState: I.Connecting,
          ...u(I.Connecting),
          local: {
            cameraTrack: null,
            microphoneTrack: null
          }
        };
      case I.Connected:
      case I.Reconnecting:
      case I.SignalReconnecting:
        return {
          ...L,
          connectionState: p,
          ...u(p),
          local: {
            cameraTrack: v,
            microphoneTrack: k
          }
        };
      case I.Disconnected:
        return {
          ...L,
          connectionState: I.Disconnected,
          ...u(I.Disconnected),
          local: {
            cameraTrack: null,
            microphoneTrack: null
          }
        };
    }
  }, [
    b,
    a,
    p,
    v,
    k,
    u
  ]);
  s.useEffect(() => {
    i.emit("connectionStateChanged", g.connectionState);
  }, [i, g.connectionState]);
  const y = bn(
    i,
    g.connectionState
  ), T = s.useCallback(
    async (L) => y(
      I.Connected,
      L
    ),
    [y]
  ), M = s.useCallback(
    async (L) => y(I.Disconnected, L),
    [y]
  ), P = Ie(
    s.useMemo(
      () => ({
        connectionState: g.connectionState,
        room: a,
        internal: b
      }),
      [g, a, b]
    )
  ), F = gn(e, o), q = s.useCallback(
    async (L = {}) => {
      var B, j;
      const {
        signal: N,
        tracks: Z = { microphone: { enabled: !0, publishOptions: { preConnectBuffer: !0 } } },
        roomConnectOptions: S
      } = L;
      await M(N);
      const _ = () => {
        a.disconnect();
      };
      N == null || N.addEventListener("abort", _);
      let Y = !1;
      await Promise.all([
        F().then(({ serverUrl: $, participantToken: z }) => {
          var be, ge;
          return Y = (((ge = (be = _t(z).roomConfig) == null ? void 0 : be.agents) == null ? void 0 : ge.length) ?? 0) > 0, a.connect($, z, S);
        }),
        // Start microphone (with preconnect buffer) by default
        (B = Z.microphone) != null && B.enabled ? a.localParticipant.setMicrophoneEnabled(
          !0,
          void 0,
          ((j = Z.microphone) == null ? void 0 : j.publishOptions) ?? {}
        ) : Promise.resolve()
      ]), await T(N), Y && await P.waitUntilConnected(N), N == null || N.removeEventListener("abort", _);
    },
    [a, M, F, T, P.waitUntilConnected]
  ), J = s.useCallback(async () => {
    await a.disconnect();
  }, [a]), K = s.useCallback(async () => {
    const L = await F();
    await a.prepareConnection(L.serverUrl, L.participantToken);
  }, [F, a]);
  return s.useEffect(
    () => {
      K().catch((L) => {
        console.warn("WARNING: Room.prepareConnection failed:", L);
      });
    },
    [
      /* note: no prepareConnection here, this effect should only ever run once! */
    ]
  ), s.useMemo(
    () => ({
      ...g,
      waitUntilConnected: T,
      waitUntilDisconnected: M,
      prepareConnection: K,
      start: q,
      end: J
    }),
    [g, T, M, K, q, J]
  );
}
function us(e, n, t, r) {
  const o = s.useMemo(() => () => {
  }, []), c = s.useCallback(t ?? o, r ?? []), a = r ? c : t, i = s.useMemo(() => e ? "internal" in e ? e.internal.emitter : e : null, [e]);
  s.useEffect(() => {
    if (!(!i || !a))
      return i.on(n, a), () => {
        i.off(n, a);
      };
  }, [i, n, a]);
}
var vn = /* @__PURE__ */ ((e) => (e.MessageReceived = "messageReceived", e))(vn || {});
function ls(e) {
  const { room: n } = Dt(e), t = s.useMemo(
    () => new he.EventEmitter(),
    []
  ), r = Ie(e), o = cn({ room: n }), c = s.useMemo(() => ({ room: n }), [n]), a = Kt(c), i = s.useMemo(() => o.map((l) => {
    var v, C, k;
    switch (l.participantInfo.identity) {
      case n.localParticipant.identity:
        return {
          type: "userTranscript",
          message: l.text,
          id: l.streamInfo.id,
          timestamp: l.streamInfo.timestamp,
          from: n.localParticipant
        };
      case ((v = r.internal.agentParticipant) == null ? void 0 : v.identity):
      case ((C = r.internal.workerParticipant) == null ? void 0 : C.identity):
        return {
          type: "agentTranscript",
          message: l.text,
          id: l.streamInfo.id,
          timestamp: l.streamInfo.timestamp,
          from: ((k = r.internal.agentParticipant) == null ? void 0 : k.identity) === l.participantInfo.identity ? r.internal.agentParticipant : r.internal.workerParticipant
        };
      default:
        return {
          type: "agentTranscript",
          message: l.text,
          id: l.streamInfo.id,
          timestamp: l.streamInfo.timestamp,
          from: Array.from(n.remoteParticipants.values()).find(
            (A) => A.identity === l.participantInfo.identity
          )
        };
    }
  }), [o, n]), u = s.useMemo(() => [...i, ...a.chatMessages], [i, a.chatMessages]), p = s.useRef(/* @__PURE__ */ new Map()), h = s.useMemo(() => {
    const l = /* @__PURE__ */ new Date();
    for (const v of u)
      p.current.has(v.id) || p.current.set(v.id, l);
    return u.sort((v, C) => {
      const k = p.current.get(v.id), A = p.current.get(C.id);
      return typeof k > "u" || typeof A > "u" ? 0 : k.getTime() - A.getTime();
    });
  }, [u]), d = s.useRef(/* @__PURE__ */ new Set());
  return s.useEffect(() => {
    for (const l of h)
      d.current.has(l.id) || (d.current.add(l.id), t.emit("messageReceived", l));
  }, [h]), s.useMemo(
    () => ({
      messages: h,
      send: a.send,
      isSending: a.isSending,
      internal: { emitter: t }
    }),
    [h, a.send, a.isSending]
  );
}
export {
  an as $,
  In as A,
  Vn as B,
  Oe as C,
  wn as D,
  An as E,
  Bt as F,
  Se as G,
  jt as H,
  xn as I,
  Un as J,
  Wt as K,
  qn as L,
  pe as M,
  jn as N,
  Gt as O,
  $n as P,
  Xn as Q,
  dn as R,
  Ie as S,
  ts as T,
  ss as U,
  re as V,
  rn as W,
  os as X,
  on as Y,
  rs as Z,
  as as _,
  te as a,
  cn as a0,
  cs as a1,
  pn as a2,
  is as a3,
  us as a4,
  vn as a5,
  ls as a6,
  Jn as b,
  Rn as c,
  Dn as d,
  Nn as e,
  zn as f,
  Wn as g,
  Kn as h,
  Ln as i,
  D as j,
  Qn as k,
  Hn as l,
  es as m,
  On as n,
  Fn as o,
  Gn as p,
  qt as q,
  zt as r,
  ns as s,
  Yn as t,
  Pn as u,
  Bn as v,
  Kt as w,
  Zn as x,
  _n as y,
  kn as z
};
//# sourceMappingURL=hooks-yU-srrIO.mjs.map
