{"version":3,"file":"shared-D30bmTxp.js","sources":["../src/context/session-context.ts","../src/hooks/useAudioPlayback.ts","../src/hooks/useClearPinButton.ts","../src/hooks/useDataChannel.ts","../src/hooks/useLiveKitRoom.ts","../src/hooks/useParticipantInfo.ts","../src/hooks/useParticipantPermissions.ts","../src/hooks/useRemoteParticipants.ts","../src/hooks/useParticipants.ts","../src/hooks/useRemoteParticipant.ts","../src/hooks/useRoomInfo.ts","../src/hooks/useSpeakingParticipants.ts","../src/hooks/useSortedParticipants.ts","../src/hooks/useToken.ts","../src/hooks/useTrackRefBySourceOrName.ts","../src/hooks/useTrackByName.ts","../src/hooks/useParticipantTracks.ts","../src/hooks/useTrackSyncTime.ts","../src/hooks/useTrackTranscription.ts","../src/hooks/useParticipantAttributes.ts","../src/hooks/useVoiceAssistant.ts","../src/hooks/useIsRecording.ts","../src/hooks/useTextStream.ts","../src/hooks/useTranscriptions.ts","../src/hooks/useSequentialRoomConnectDisconnect.ts","../../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","../src/hooks/useAgent.ts","../src/hooks/useSession.ts","../src/hooks/useEvents.ts","../src/hooks/useSessionMessages.ts"],"sourcesContent":["import * as React from 'react';\n\nimport { UseSessionReturn } from '../hooks/useSession';\n\n/** @internal */\nexport const SessionContext = React.createContext<UseSessionReturn | undefined>(undefined);\n\n/**\n * Ensures that a session is provided via context.\n * If no session is provided, an error is thrown.\n * @beta\n */\nexport function useSessionContext() {\n  const ctx = React.useContext(SessionContext);\n  if (!ctx) {\n    throw Error('tried to access session context outside of SessionProvider component');\n  }\n  return ctx;\n}\n\n/**\n * Returns the session context if it exists, otherwise undefined.\n * @beta\n */\nexport function useMaybeSessionContext() {\n  return React.useContext(SessionContext);\n}\n\n/**\n * Ensures that a session is provided, either via context or explicitly as a parameter.\n * If no session is provided, an error is thrown.\n * @beta\n */\nexport function useEnsureSession(session?: UseSessionReturn) {\n  const context = useMaybeSessionContext();\n  const r = session ?? context;\n  if (!r) {\n    throw new Error(\n      'No session provided, make sure you are inside a Session context or pass the session explicitly',\n    );\n  }\n  return r;\n}\n","import type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useObservableState } from './internal';\nimport { roomAudioPlaybackAllowedObservable } from '@livekit/components-core';\nimport { useEnsureRoom } from '../context';\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useAudioPlayback` hook returns an object with a boolean `canPlayAudio` flag that indicates whether audio\n * playback is allowed in the current context, as well as a `startAudio` function that can be called in a button\n * `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useAudioPlayback(room?: Room): {\n  canPlayAudio: boolean;\n  startAudio: () => Promise<void>;\n} {\n  const roomEnsured = useEnsureRoom(room);\n  const startAudio = React.useCallback(async () => {\n    await roomEnsured.startAudio();\n  }, [roomEnsured]);\n\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured],\n  );\n  const { canPlayAudio } = useObservableState(observable, {\n    canPlayAudio: roomEnsured.canPlaybackAudio,\n  });\n\n  return { canPlayAudio, startAudio };\n}\n","import { setupClearPinButton } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport type { ClearPinButtonProps } from '../components';\n\n/**\n * The `useClearPinButton` hook provides props for the {@link ClearPinButton}\n * or your custom implementation of it component. It adds the `onClick` handler\n * to signal the `LayoutContext` that the tile in focus should be cleared.\n * @public\n */\nexport function useClearPinButton(props: ClearPinButtonProps) {\n  const { state, dispatch } = useLayoutContext().pin;\n\n  const buttonProps = React.useMemo(() => {\n    const { className } = setupClearPinButton();\n    const mergedProps = mergeProps(props, {\n      className,\n      disabled: !state?.length,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'clear_pin' });\n      },\n    });\n    return mergedProps;\n  }, [props, dispatch, state]);\n\n  return { buttonProps };\n}\n","import type { ReceivedDataMessage } from '@livekit/components-core';\nimport { setupDataMessageHandler } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { DataPublishOptions } from 'livekit-client';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\ntype UseDataChannelReturnType<T extends string | undefined = undefined> = {\n  isSending: boolean;\n  send: (payload: Uint8Array, options: DataPublishOptions) => Promise<void>;\n  message: ReceivedDataMessage<T> | undefined;\n};\n\n/**\n * The `useDataChannel` hook returns the ability to send and receive messages.\n * Pass an optional `topic` to narrow down which messages are returned in the messages array.\n *\n * @remarks\n * There is only one data channel. Passing a `topic` does not open a new data channel.\n * It is only used to filter out messages with no or a different `topic`.\n *\n * @example\n * ```tsx\n * // Send messages to all participants via the 'chat' topic.\n * const { message: latestMessage, send } = useDataChannel('chat', (msg) => console.log(\"message received\", msg));\n * ```\n *\n * @example\n * ```tsx\n * // Receive all messages (no topic filtering)\n * const { message: latestMessage, send } = useDataChannel((msg) => console.log(\"message received\", msg));\n * ```\n *\n * @public\n */\nexport function useDataChannel<T extends string>(\n  topic: T,\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\n): UseDataChannelReturnType<T>;\n\n/**\n * Overload for `useDataChannel` without a topic. See {@link (useDataChannel:1)} for information and usage examples.\n *\n * @public\n */\nexport function useDataChannel(\n  onMessage?: (msg: ReceivedDataMessage) => void,\n): UseDataChannelReturnType;\n/**\n * @internal\n */\nexport function useDataChannel<T extends string>(\n  topicOrCallback?: T | ((msg: ReceivedDataMessage) => void),\n  callback?: (msg: ReceivedDataMessage<T>) => void,\n) {\n  const onMessage = typeof topicOrCallback === 'function' ? topicOrCallback : callback;\n\n  const topic = typeof topicOrCallback === 'string' ? topicOrCallback : undefined;\n  const room = useRoomContext();\n  const { send, messageObservable, isSendingObservable } = React.useMemo(\n    () => setupDataMessageHandler(room, topic, onMessage),\n    [room, topic, onMessage],\n  );\n\n  const message = useObservableState(messageObservable, undefined);\n  const isSending = useObservableState(isSendingObservable, false);\n\n  return {\n    message,\n    send,\n    isSending,\n  };\n}\n","import { log, setupLiveKitRoom } from '@livekit/components-core';\nimport type { DisconnectReason } from 'livekit-client';\nimport { Room, MediaDeviceFailure, RoomEvent } from 'livekit-client';\nimport * as React from 'react';\nimport type { HTMLAttributes } from 'react';\n\nimport type { LiveKitRoomProps } from '../components';\nimport { mergeProps } from '../mergeProps';\nimport { roomOptionsStringifyReplacer } from '../utils';\n\nconst defaultRoomProps: Partial<LiveKitRoomProps> = {\n  connect: true,\n  audio: false,\n  video: false,\n};\n\n/**\n * The `useLiveKitRoom` hook is used to implement the `LiveKitRoom` or your custom implementation of it.\n * It returns a `Room` instance and HTML props that should be applied to the root element of the component.\n *\n * @example\n * ```tsx\n * const { room, htmlProps } = useLiveKitRoom();\n * return <div {...htmlProps}>...</div>;\n * ```\n * @public\n */\nexport function useLiveKitRoom<T extends HTMLElement>(\n  props: LiveKitRoomProps,\n): {\n  room: Room | undefined;\n  htmlProps: HTMLAttributes<T>;\n} {\n  const {\n    token,\n    serverUrl,\n    options,\n    room: passedRoom,\n    connectOptions,\n    connect,\n    audio,\n    video,\n    screen,\n    onConnected,\n    onDisconnected,\n    onError,\n    onMediaDeviceFailure,\n    onEncryptionError,\n    simulateParticipants,\n    ...rest\n  } = { ...defaultRoomProps, ...props };\n  if (options && passedRoom) {\n    log.warn(\n      'when using a manually created room, the options object will be ignored. set the desired options directly when creating the room instead.',\n    );\n  }\n\n  const [room, setRoom] = React.useState<Room | undefined>();\n\n  const shouldConnect = React.useRef(connect);\n\n  React.useEffect(() => {\n    setRoom(passedRoom ?? new Room(options));\n  }, [passedRoom, JSON.stringify(options, roomOptionsStringifyReplacer)]);\n\n  const htmlProps = React.useMemo(() => {\n    const { className } = setupLiveKitRoom();\n    return mergeProps(rest, { className }) as HTMLAttributes<T>;\n  }, [rest]);\n\n  React.useEffect(() => {\n    if (!room) return;\n    const onSignalConnected = () => {\n      const localP = room.localParticipant;\n\n      log.debug('trying to publish local tracks');\n      Promise.all([\n        localP.setMicrophoneEnabled(!!audio, typeof audio !== 'boolean' ? audio : undefined),\n        localP.setCameraEnabled(!!video, typeof video !== 'boolean' ? video : undefined),\n        localP.setScreenShareEnabled(!!screen, typeof screen !== 'boolean' ? screen : undefined),\n      ]).catch((e) => {\n        log.warn(e);\n        onError?.(e as Error);\n      });\n    };\n\n    const handleMediaDeviceError = (e: Error, kind?: MediaDeviceKind) => {\n      const mediaDeviceFailure = MediaDeviceFailure.getFailure(e);\n      onMediaDeviceFailure?.(mediaDeviceFailure, kind);\n    };\n    const handleEncryptionError = (e: Error) => {\n      onEncryptionError?.(e);\n    };\n    const handleDisconnected = (reason?: DisconnectReason) => {\n      onDisconnected?.(reason);\n    };\n    const handleConnected = () => {\n      onConnected?.();\n    };\n\n    room\n      .on(RoomEvent.SignalConnected, onSignalConnected)\n      .on(RoomEvent.MediaDevicesError, handleMediaDeviceError)\n      .on(RoomEvent.EncryptionError, handleEncryptionError)\n      .on(RoomEvent.Disconnected, handleDisconnected)\n      .on(RoomEvent.Connected, handleConnected);\n\n    return () => {\n      room\n        .off(RoomEvent.SignalConnected, onSignalConnected)\n        .off(RoomEvent.MediaDevicesError, handleMediaDeviceError)\n        .off(RoomEvent.EncryptionError, handleEncryptionError)\n        .off(RoomEvent.Disconnected, handleDisconnected)\n        .off(RoomEvent.Connected, handleConnected);\n    };\n  }, [\n    room,\n    audio,\n    video,\n    screen,\n    onError,\n    onEncryptionError,\n    onMediaDeviceFailure,\n    onConnected,\n    onDisconnected,\n  ]);\n\n  React.useEffect(() => {\n    if (!room) return;\n\n    if (simulateParticipants) {\n      room.simulateParticipants({\n        participants: {\n          count: simulateParticipants,\n        },\n        publish: {\n          audio: true,\n          useRealTracks: true,\n        },\n      });\n      return;\n    }\n\n    if (connect) {\n      shouldConnect.current = true;\n      log.debug('connecting');\n      if (!token) {\n        log.debug('no token yet');\n        return;\n      }\n      if (!serverUrl) {\n        log.warn('no livekit url provided');\n        onError?.(Error('no livekit url provided'));\n        return;\n      }\n      room.connect(serverUrl, token, connectOptions).catch((e) => {\n        log.warn(e);\n        if (shouldConnect.current === true) {\n          onError?.(e as Error);\n        }\n      });\n    } else {\n      log.debug('disconnecting because connect is false');\n      shouldConnect.current = false;\n      room.disconnect();\n    }\n  }, [\n    connect,\n    token,\n    JSON.stringify(connectOptions),\n    room,\n    onError,\n    serverUrl,\n    simulateParticipants,\n  ]);\n\n  React.useEffect(() => {\n    if (!room) return;\n    return () => {\n      log.info('disconnecting on onmount');\n      room.disconnect();\n    };\n  }, [room]);\n\n  return { room, htmlProps };\n}\n","import { participantInfoObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeParticipantContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantInfo` hook returns the identity, name, and metadata of a given participant.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { identity, name, metadata } = useParticipantInfo({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantInfoOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantInfo(props: UseParticipantInfoOptions = {}) {\n  let p = useMaybeParticipantContext();\n  if (props.participant) {\n    p = props.participant;\n  }\n  const infoObserver = React.useMemo(() => participantInfoObserver(p), [p]);\n  const { identity, name, metadata } = useObservableState(infoObserver, {\n    name: p?.name,\n    identity: p?.identity,\n    metadata: p?.metadata,\n  });\n\n  return { identity, name, metadata };\n}\n","import { participantPermissionObserver } from '@livekit/components-core';\nimport type { ParticipantPermission } from '@livekit/protocol';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal/useObservableState';\n\n/**\n * The `useParticipantPermissions` hook returns the permissions of a given participant.\n *\n * @example\n * ```tsx\n * const permissions = useParticipantPermissions({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantPermissionsOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantPermissions(\n  options: UseParticipantPermissionsOptions = {},\n): ParticipantPermission | undefined {\n  const p = useEnsureParticipant(options.participant);\n  const permissionObserver = React.useMemo(() => participantPermissionObserver(p), [p]);\n  const permissions = useObservableState(permissionObserver, p.permissions);\n  return permissions;\n}\n","import { connectedParticipantsObserver } from '@livekit/components-core';\nimport type { RoomEvent, RemoteParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useRemoteParticipants` hook returns all remote participants (without the local) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useRemoteParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useRemoteParticipants(options: UseRemoteParticipantsOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [participants, setParticipants] = React.useState<RemoteParticipant[]>([]);\n\n  React.useEffect(() => {\n    const listener = connectedParticipantsObserver(room, {\n      additionalRoomEvents: options.updateOnlyOn,\n    }).subscribe(setParticipants);\n    return () => listener.unsubscribe();\n  }, [room, JSON.stringify(options.updateOnlyOn)]);\n  return participants;\n}\n","import type { Room, RoomEvent } from 'livekit-client';\nimport { useLocalParticipant } from './useLocalParticipant';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useParticipants` hook returns all participants (local and remote) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useParticipants(options: UseParticipantsOptions = {}) {\n  const remoteParticipants = useRemoteParticipants(options);\n  const { localParticipant } = useLocalParticipant(options);\n\n  return React.useMemo(\n    () => [localParticipant, ...remoteParticipants],\n    [localParticipant, remoteParticipants],\n  );\n}\n","import {\n  type ParticipantIdentifier,\n  connectedParticipantObserver,\n  participantByIdentifierObserver,\n} from '@livekit/components-core';\nimport type { ParticipantEvent, RemoteParticipant } from 'livekit-client';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n   * By default it updates on all relevant ParticipantEvents to keep the returned participant up to date.\n   */\n  updateOnlyOn?: ParticipantEvent[];\n}\n\n/**\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity and/or based on the participant kind.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant({kind: ParticipantKind.Agent, identity: 'myAgent'});\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identifier: ParticipantIdentifier,\n  options?: UseRemoteParticipantOptions,\n): RemoteParticipant | undefined;\n/**\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity or based on the participant kind.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant('Russ');\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identity: string,\n  options?: UseRemoteParticipantOptions,\n): RemoteParticipant | undefined;\nexport function useRemoteParticipant(\n  identityOrIdentifier: string | ParticipantIdentifier,\n  options: UseRemoteParticipantOptions = {},\n): RemoteParticipant | undefined {\n  const room = useRoomContext();\n  const [updateOnlyOn] = React.useState(options.updateOnlyOn);\n\n  const observable = React.useMemo(() => {\n    if (typeof identityOrIdentifier === 'string') {\n      return connectedParticipantObserver(room, identityOrIdentifier, {\n        additionalEvents: updateOnlyOn,\n      });\n    } else {\n      return participantByIdentifierObserver(room, identityOrIdentifier, {\n        additionalEvents: updateOnlyOn,\n      });\n    }\n  }, [room, JSON.stringify(identityOrIdentifier), updateOnlyOn]);\n\n  // Using `wrapperParticipant` to ensure a new object reference,\n  // triggering a re-render when the participant events fire.\n  const [participantWrapper, setParticipantWrapper] = React.useState({\n    p: undefined as RemoteParticipant | undefined,\n  });\n  React.useEffect(() => {\n    const listener = observable.subscribe((p) => setParticipantWrapper({ p }));\n    return () => listener.unsubscribe();\n  }, [observable]);\n\n  return participantWrapper.p;\n}\n","import { roomInfoObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useRoomInfo` hook returns the name and metadata of the given `Room`.\n * @remarks\n * Needs to be called inside a `RoomContext` or by passing a `Room` instance.\n *\n * @example\n * ```tsx\n * const { name, metadata } = useRoomInfo();\n * ```\n * @public\n */\nexport interface UseRoomInfoOptions {\n  room?: Room;\n}\n\n/** @public */\nexport function useRoomInfo(options: UseRoomInfoOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const infoObserver = React.useMemo(() => roomInfoObserver(room), [room]);\n  const { name, metadata } = useObservableState(infoObserver, {\n    name: room.name,\n    metadata: room.metadata,\n  });\n\n  return { name, metadata };\n}\n","import { activeSpeakerObserver } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\nimport { Room } from 'livekit-client';\n\n/** @public */\nexport type UseSpeakingParticipantsOptions = {\n  room?: Room;\n};\n\n/**\n * The `useSpeakingParticipants` hook returns only the active speakers of all participants.\n *\n * @example\n * ```tsx\n * const activeSpeakers = useSpeakingParticipants();\n * ```\n * @public\n */\nexport function useSpeakingParticipants(options?: UseSpeakingParticipantsOptions) {\n  const ensuredRoom = useEnsureRoom(options?.room);\n\n  const speakerObserver = React.useMemo(() => activeSpeakerObserver(ensuredRoom), [ensuredRoom]);\n  const activeSpeakers = useObservableState(speakerObserver, ensuredRoom.activeSpeakers);\n  return activeSpeakers;\n}\n","import { sortParticipants } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useSpeakingParticipants } from './useSpeakingParticipants';\n\n/**\n * The `useSortedParticipants` hook returns the participants sorted by importance.\n * @public\n */\nexport function useSortedParticipants(participants: Array<Participant>) {\n  const [sortedParticipants, setSortedParticipants] = React.useState(\n    sortParticipants(participants),\n  );\n  const activeSpeakers = useSpeakingParticipants();\n\n  React.useEffect(() => {\n    setSortedParticipants(sortParticipants(participants));\n  }, [activeSpeakers, participants]);\n  return sortedParticipants;\n}\n","import { log } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UserInfo {\n  identity?: string;\n  name?: string;\n  metadata?: string;\n}\n\n/** @public */\nexport interface UseTokenOptions {\n  userInfo?: UserInfo;\n}\n\n/**\n * The `useToken` hook fetches a token from the given token endpoint with the given user info.\n *\n * @example\n * ```tsx\n * const token = useToken(<token-endpoint>, roomName, { userInfo: { identity, name }});\n * ```\n * @public */\nexport function useToken(\n  tokenEndpoint: string | undefined,\n  roomName: string,\n  options: UseTokenOptions = {},\n) {\n  const [token, setToken] = React.useState<string | undefined>(undefined);\n\n  React.useEffect(() => {\n    if (tokenEndpoint === undefined) {\n      throw Error('token endpoint needs to be defined');\n    }\n    if (options.userInfo?.identity === undefined) {\n      return;\n    }\n    const tokenFetcher = async () => {\n      log.debug('fetching token');\n      const params = new URLSearchParams({ ...options.userInfo, roomName });\n      const res = await fetch(`${tokenEndpoint}?${params.toString()}`);\n      if (!res.ok) {\n        log.error(\n          `Could not fetch token. Server responded with status ${res.status}: ${res.statusText}`,\n        );\n        return;\n      }\n      const { accessToken } = await res.json();\n      setToken(accessToken);\n    };\n    tokenFetcher();\n  }, [tokenEndpoint, roomName, JSON.stringify(options)]);\n  return token;\n}\n","import type { TrackReferenceOrPlaceholder, TrackSource } from '@livekit/components-core';\nimport { setupMediaTrack, getTrackByIdentifier } from '@livekit/components-core';\nimport * as React from 'react';\nimport { Track } from 'livekit-client';\n\n/**\n * @internal\n */\nexport function useTrackRefBySourceOrName(\n  source: TrackSource<Track.Source>,\n): TrackReferenceOrPlaceholder {\n  const [publication, setPublication] = React.useState(getTrackByIdentifier(source));\n\n  const { trackObserver } = React.useMemo(() => {\n    return setupMediaTrack(source);\n  }, [source.participant.sid ?? source.participant.identity, source.source]);\n\n  React.useEffect(() => {\n    const subscription = trackObserver.subscribe((publication) => {\n      setPublication(publication);\n    });\n    return () => subscription?.unsubscribe();\n  }, [trackObserver]);\n\n  return {\n    participant: source.participant,\n    source: source.source ?? Track.Source.Unknown,\n    publication,\n  };\n}\n","import type { Participant } from 'livekit-client';\nimport { useEnsureParticipant } from '../context';\nimport { useTrackRefBySourceOrName } from './useTrackRefBySourceOrName';\n\n/**\n * This function `useTrackByName` allows you to access a track by referencing its track name.\n * Inside the function, it ensures that the a valid `participant` reference is available by checking\n * for both a passed participant argument and, if not available, a valid participant context.\n *\n * @public\n */\nexport function useTrackByName(name: string, participant?: Participant) {\n  const p = useEnsureParticipant(participant);\n  return useTrackRefBySourceOrName({ name, participant: p });\n}\n","import * as React from 'react';\nimport type { TrackReference } from '@livekit/components-core';\nimport { participantTracksObservable } from '@livekit/components-core';\nimport { useObservableState } from './internal';\nimport type { Room, Track } from 'livekit-client';\nimport { useMaybeParticipantContext } from '../context';\nimport { useParticipants } from './useParticipants';\n\ntype UseParticipantTracksOptions = {\n  participantIdentity?: string;\n  room?: Room;\n};\n\n/**\n * `useParticipantTracks` is a custom React that allows you to get tracks of a specific participant only, by specifiying the participant's identity.\n * If the participant identity is not passed the hook will try to get the participant from a participant context.\n * @public\n */\nexport function useParticipantTracks<TrackSource extends Track.Source>(\n  sources: Array<TrackSource>,\n  optionsOrParticipantIdentity:\n    | UseParticipantTracksOptions\n    | UseParticipantTracksOptions['participantIdentity'] = {},\n): Array<TrackReference> {\n  let participantIdentity: UseParticipantTracksOptions['participantIdentity'];\n  let room: UseParticipantTracksOptions['room'];\n  if (typeof optionsOrParticipantIdentity === 'string') {\n    participantIdentity = optionsOrParticipantIdentity;\n  } else {\n    participantIdentity = optionsOrParticipantIdentity?.participantIdentity;\n    room = optionsOrParticipantIdentity?.room;\n  }\n\n  const participantContext = useMaybeParticipantContext();\n  const participants = useParticipants({ room, updateOnlyOn: [] });\n\n  const p = React.useMemo(() => {\n    if (participantIdentity) {\n      return participants.find((p) => p.identity === participantIdentity);\n    }\n    return participantContext;\n  }, [participantIdentity, participants, participantContext]);\n\n  const observable = React.useMemo(() => {\n    if (!p) {\n      return undefined;\n    }\n    return participantTracksObservable(p, { sources });\n  }, [p, JSON.stringify(sources)]);\n\n  const trackRefs = useObservableState(observable, [] as Array<TrackReference>);\n\n  return trackRefs;\n}\n","import * as React from 'react';\nimport { type TrackReferenceOrPlaceholder, trackSyncTimeObserver } from '@livekit/components-core';\nimport { useObservableState } from './internal';\n\n/**\n * @internal\n * @deprecated this is an internal hook that's only used by deprecated APIs\n */\nexport function useTrackSyncTime(ref: TrackReferenceOrPlaceholder | undefined) {\n  const observable = React.useMemo(\n    () => (ref?.publication?.track ? trackSyncTimeObserver(ref?.publication.track) : undefined),\n    [ref?.publication?.track],\n  );\n  return useObservableState(observable, {\n    timestamp: Date.now(),\n    rtpTimestamp: ref?.publication?.track?.rtpTimestamp,\n  });\n}\n","import {\n  type ReceivedTranscriptionSegment,\n  addMediaTimestampToTranscription as addTimestampsToTranscription,\n  dedupeSegments,\n  // getActiveTranscriptionSegments,\n  getTrackReferenceId,\n  trackTranscriptionObserver,\n  type TrackReferenceOrPlaceholder,\n  // didActiveSegmentsChange,\n} from '@livekit/components-core';\nimport type { TranscriptionSegment } from 'livekit-client';\nimport * as React from 'react';\nimport { useTrackSyncTime } from './useTrackSyncTime';\n\n/**\n * @alpha\n * @deprecated Use useTranscription instead\n */\nexport interface TrackTranscriptionOptions {\n  /**\n   * how many transcription segments should be buffered in state\n   * @defaultValue 100\n   */\n  bufferSize?: number;\n  /**\n   * optional callback for retrieving newly incoming transcriptions only\n   */\n  onTranscription?: (newSegments: TranscriptionSegment[]) => void;\n  /** amount of time (in ms) that the segment is considered `active` past its original segment duration, defaults to 2_000 */\n  // maxAge?: number;\n}\n\nconst TRACK_TRANSCRIPTION_DEFAULTS = {\n  bufferSize: 100,\n  // maxAge: 2_000,\n} as const satisfies TrackTranscriptionOptions;\n\n/**\n * @returns An object consisting of `segments` with maximum length of opts.bufferSize\n * @alpha\n * @deprecated Use useTranscription instead\n */\nexport function useTrackTranscription(\n  trackRef: TrackReferenceOrPlaceholder | undefined,\n  options?: TrackTranscriptionOptions,\n) {\n  const opts = { ...TRACK_TRANSCRIPTION_DEFAULTS, ...options };\n  const [segments, setSegments] = React.useState<Array<ReceivedTranscriptionSegment>>([]);\n\n  const syncTimestamps = useTrackSyncTime(trackRef);\n  const handleSegmentMessage = (newSegments: TranscriptionSegment[]) => {\n    opts.onTranscription?.(newSegments);\n    setSegments((prevSegments) =>\n      dedupeSegments(\n        prevSegments,\n        // when first receiving a segment, add the current media timestamp to it\n        newSegments.map((s) => addTimestampsToTranscription(s, syncTimestamps)),\n        opts.bufferSize,\n      ),\n    );\n  };\n  React.useEffect(() => {\n    if (!trackRef?.publication) {\n      return;\n    }\n    const subscription = trackTranscriptionObserver(trackRef.publication).subscribe((evt) => {\n      handleSegmentMessage(...evt);\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [trackRef && getTrackReferenceId(trackRef), handleSegmentMessage]);\n\n  return { segments };\n}\n","import { participantAttributesObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant, useMaybeParticipantContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantAttributes` hook returns the attributes of a given participant and allows to set them.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { attributes } = useParticipantAttributes({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantAttributesOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantAttributes(props: UseParticipantAttributesOptions = {}) {\n  const participantContext = useMaybeParticipantContext();\n  const p = props.participant ?? participantContext;\n  const attributeObserver = React.useMemo(\n    // weird typescript constraint\n    () => (p ? participantAttributesObserver(p) : participantAttributesObserver(p)),\n    [p],\n  );\n  const attributeState = useObservableState(attributeObserver, {\n    attributes: p?.attributes,\n  });\n\n  return attributeState;\n}\n\n/**\n * The `useParticipantAttribute` hook returns the latest value of a given attribute key of a participant.\n * It requires a `Participant` object passed as property in the `UseParticipantAttributesOptions` or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const myAttributeValue = useParticipantAttribute('targetAttributeName');\n * ```\n * @public\n */\nexport function useParticipantAttribute(\n  attributeKey: string,\n  options: UseParticipantAttributesOptions = {},\n) {\n  const p = useEnsureParticipant(options.participant);\n  const [attribute, setAttribute] = React.useState(p.attributes[attributeKey]);\n\n  React.useEffect(() => {\n    if (!p) {\n      return;\n    }\n    const subscription = participantAttributesObserver(p).subscribe((val) => {\n      if (val.changed[attributeKey] !== undefined) {\n        setAttribute(val.attributes[attributeKey]);\n      }\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [p, attributeKey]);\n\n  return attribute;\n}\n","import * as React from 'react';\nimport { ConnectionState, ParticipantKind, Track } from 'livekit-client';\nimport type { RemoteParticipant } from 'livekit-client';\nimport {\n  ParticipantAgentAttributes,\n  type ReceivedTranscriptionSegment,\n  type TrackReference,\n} from '@livekit/components-core';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport { useParticipantTracks } from './useParticipantTracks';\nimport { useTrackTranscription } from './useTrackTranscription';\nimport { useConnectionState } from './useConnectionStatus';\nimport { useParticipantAttributes } from './useParticipantAttributes';\nimport { AgentState } from './useAgent';\n\n/**\n * @beta\n */\nexport interface VoiceAssistant {\n  /**\n   * The agent participant.\n   */\n  agent: RemoteParticipant | undefined;\n  /**\n   * The current state of the agent.\n   */\n  state: AgentState;\n  /**\n   * The microphone track published by the agent or associated avatar worker (if any).\n   */\n  audioTrack: TrackReference | undefined;\n  /**\n   * The camera track published by the agent or associated avatar worker (if any).\n   */\n  videoTrack: TrackReference | undefined;\n  /**\n   * The transcriptions of the agent's microphone track (if any).\n   */\n  agentTranscriptions: ReceivedTranscriptionSegment[];\n  /**\n   * The agent's participant attributes.\n   */\n  agentAttributes: RemoteParticipant['attributes'] | undefined;\n}\n\nconst state_attribute = ParticipantAgentAttributes.AgentState;\n\n/**\n * This hook looks for the first agent-participant in the room.\n * @remarks This hook requires an agent running with livekit-agents \\>= 0.9.0\n * @example\n * ```tsx\n * const { state, audioTrack, agentTranscriptions, agentAttributes } = useVoiceAssistant();\n * ```\n * @beta\n */\nexport function useVoiceAssistant(): VoiceAssistant {\n  const remoteParticipants = useRemoteParticipants();\n  const agent = remoteParticipants.find(\n    (p) =>\n      p.kind === ParticipantKind.AGENT &&\n      !(ParticipantAgentAttributes.PublishOnBehalf in p.attributes),\n  );\n  const worker = remoteParticipants.find(\n    (p) =>\n      p.kind === ParticipantKind.AGENT &&\n      p.attributes[ParticipantAgentAttributes.PublishOnBehalf] === agent?.identity,\n  );\n  const agentTracks = useParticipantTracks(\n    [Track.Source.Microphone, Track.Source.Camera],\n    agent?.identity,\n  );\n  const workerTracks = useParticipantTracks(\n    [Track.Source.Microphone, Track.Source.Camera],\n    worker?.identity,\n  );\n  const audioTrack =\n    agentTracks.find((t) => t.source === Track.Source.Microphone) ??\n    workerTracks.find((t) => t.source === Track.Source.Microphone);\n  const videoTrack =\n    agentTracks.find((t) => t.source === Track.Source.Camera) ??\n    workerTracks.find((t) => t.source === Track.Source.Camera);\n  const { segments: agentTranscriptions } = useTrackTranscription(audioTrack);\n  const connectionState = useConnectionState();\n  const { attributes } = useParticipantAttributes({ participant: agent });\n\n  const state: AgentState = React.useMemo(() => {\n    if (connectionState === ConnectionState.Disconnected) {\n      return 'disconnected';\n    } else if (\n      connectionState === ConnectionState.Connecting ||\n      !agent ||\n      !attributes?.[state_attribute]\n    ) {\n      return 'connecting';\n    } else {\n      return attributes[state_attribute] as AgentState;\n    }\n  }, [attributes, agent, connectionState]);\n\n  return {\n    agent,\n    state,\n    audioTrack,\n    videoTrack,\n    agentTranscriptions,\n    agentAttributes: attributes,\n  };\n}\n","import { recordingStatusObservable } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\nimport { useConnectionState } from './useConnectionStatus';\nimport type { Room } from 'livekit-client';\n\n/**\n * The `useIsRecording` hook returns a `boolean` that indicates if the room is currently being recorded.\n * @example\n * ```tsx\n * const isRecording = useIsRecording();\n * ```\n * @public\n */\nexport function useIsRecording(room?: Room) {\n  const r = useEnsureRoom(room);\n  const connectionState = useConnectionState(r);\n  const observable = React.useMemo(() => recordingStatusObservable(r), [r, connectionState]);\n  const isRecording = useObservableState(observable, r.isRecording);\n\n  return isRecording;\n}\n","import * as React from 'react';\nimport { ConnectionState, Room } from 'livekit-client';\nimport { setupTextStream, type TextStreamData } from '@livekit/components-core';\nimport { useEnsureRoom } from '../context';\nimport { useConnectionState } from './useConnectionStatus';\nimport { useObservableState } from './internal';\n\n/** @beta */\nexport type UseTextStreamOptions = {\n  room?: Room;\n};\n\n/**\n * @beta\n * @param topic - the topic to listen to\n * @returns an array of TextStreamData that holds the text, participantInfo, and streamInfo\n * @example\n * ```tsx\n * const { textStreams } = useTextStream('my-topic');\n * return <div>{textStreams.map((textStream) => textStream.text)}</div>;\n * ```\n */\nexport function useTextStream(topic: string, options?: UseTextStreamOptions) {\n  const room = useEnsureRoom(options?.room);\n\n  const connectionState = useConnectionState(room);\n  const isDisconnected = connectionState === ConnectionState.Disconnected;\n\n  const textStreamData = React.useMemo(() => setupTextStream(room, topic), [room, topic]);\n  const textStreamObservable = isDisconnected ? undefined : textStreamData;\n\n  const textStreams = useObservableState<TextStreamData[]>(textStreamObservable, []);\n\n  return { textStreams };\n}\n","import * as React from 'react';\nimport { useTextStream } from './useTextStream';\nimport { DataTopic, ParticipantAgentAttributes } from '@livekit/components-core';\nimport { Room } from 'livekit-client';\n\n/**\n * @beta\n */\nexport interface UseTranscriptionsOptions {\n  room?: Room;\n  participantIdentities?: string[];\n  trackSids?: string[];\n}\n\n/**\n * @beta\n * useTranscriptions is a hook that returns the transcriptions for the given participant identities and track sids,\n * if no options are provided, it will return all transcriptions\n * @example\n * ```tsx\n * const transcriptions = useTranscriptions();\n * return <div>{transcriptions.map((transcription) => transcription.text)}</div>;\n * ```\n */\nexport function useTranscriptions(opts?: UseTranscriptionsOptions) {\n  const { participantIdentities, trackSids } = opts ?? {};\n  const { textStreams } = useTextStream(DataTopic.TRANSCRIPTION, { room: opts?.room });\n\n  const filteredMessages = React.useMemo(\n    () =>\n      textStreams\n        .filter((stream) =>\n          participantIdentities\n            ? participantIdentities.includes(stream.participantInfo.identity)\n            : true,\n        )\n        .filter((stream) =>\n          trackSids\n            ? trackSids.includes(\n                stream.streamInfo.attributes?.[ParticipantAgentAttributes.TranscribedTrackId] ?? '',\n              )\n            : true,\n        ),\n    [textStreams, participantIdentities, trackSids],\n  );\n\n  return filteredMessages;\n}\n","import { Mutex, type Room } from 'livekit-client';\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\nimport { log } from '@livekit/components-core';\n\nconst CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY = 2;\nconst CONNECT_DISCONNECT_WARNING_THRESHOLD_MS = 400;\n\nconst ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY = 3;\nconst ROOM_CHANGE_WARNING_THRESHOLD_MS = 1000;\n\n/** @public */\nexport type UseSequentialRoomConnectDisconnectResults<R extends Room | undefined> = {\n  connect: typeof Room.prototype.connect & (R extends undefined ? null : unknown);\n  disconnect: typeof Room.prototype.disconnect & (R extends undefined ? null : unknown);\n};\n\n/**\n * When calling room.disconnect() as part of a React useEffect cleanup function, it is possible for\n * a room.connect(...) in the effect body to start running while the room.disconnect() is still\n * running. This hook sequentializes these two operations, so they always happen in order and\n * never overlap.\n *\n * @example\n * ```ts\n * const { connect, disconnect } = useSequentialRoomConnectDisconnect(room);\n *\n * // Connecting to a room:\n * useEffect(() => {\n *   connect();\n *   return () => disconnect();\n * }, [connect, disconnect]);\n * ```\n *\n * @public\n */\nexport function useSequentialRoomConnectDisconnect<R extends Room | undefined>(\n  room: R,\n): UseSequentialRoomConnectDisconnectResults<R> {\n  const connectDisconnectQueueRef = useRef<\n    Array<\n      | {\n          type: 'connect';\n          room: Room;\n          args: Parameters<typeof Room.prototype.connect>;\n          resolve: (value: Awaited<ReturnType<typeof Room.prototype.connect>>) => void;\n          reject: (err: Error) => void;\n        }\n      | {\n          type: 'disconnect';\n          room: Room;\n          args: Parameters<typeof Room.prototype.disconnect>;\n          resolve: (value: Awaited<ReturnType<typeof Room.prototype.disconnect>>) => void;\n          reject: (err: Error) => void;\n        }\n    >\n  >([]);\n\n  // Process room connection / disconnection events and execute them in series\n  // The main queue is a ref, so one invocation of this function can continue to process newly added\n  // events\n  const processConnectsAndDisconnectsLock = useMemo(() => new Mutex(), []);\n  const processConnectsAndDisconnects = useCallback(async () => {\n    return processConnectsAndDisconnectsLock.lock().then(async (unlock) => {\n      while (true) {\n        const message = connectDisconnectQueueRef.current.pop();\n        if (!message) {\n          unlock();\n          break;\n        }\n\n        switch (message.type) {\n          case 'connect':\n            await message.room\n              .connect(...message.args)\n              .then(message.resolve)\n              .catch(message.reject);\n            break;\n          case 'disconnect':\n            await message.room\n              .disconnect(...message.args)\n              .then(message.resolve)\n              .catch(message.reject);\n            break;\n        }\n      }\n    });\n  }, []);\n\n  const roomChangedTimesRef = useRef<Array<Date>>([]);\n  const checkRoomThreshold = useCallback((now: Date) => {\n    let roomChangesInThreshold = 0;\n    roomChangedTimesRef.current = roomChangedTimesRef.current.filter((i) => {\n      const isWithinThreshold = now.getTime() - i.getTime() < ROOM_CHANGE_WARNING_THRESHOLD_MS;\n      if (isWithinThreshold) {\n        roomChangesInThreshold += 1;\n      }\n      return isWithinThreshold;\n    });\n\n    if (roomChangesInThreshold > ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY) {\n      log.warn(\n        `useSequentialRoomConnectDisconnect: room changed reference rapidly (over ${ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY}x in ${ROOM_CHANGE_WARNING_THRESHOLD_MS}ms). This is not recommended.`,\n      );\n    }\n  }, []);\n\n  // When the room changes, clear any pending connect / disconnect calls and log when it happened\n  useEffect(() => {\n    connectDisconnectQueueRef.current = [];\n\n    const now = new Date();\n    roomChangedTimesRef.current.push(now);\n    checkRoomThreshold(now);\n  }, [room, checkRoomThreshold]);\n\n  const connectDisconnectEnqueueTimes = useRef<Array<Date>>([]);\n  const checkConnectDisconnectThreshold = useCallback((now: Date) => {\n    let connectDisconnectsInThreshold = 0;\n    connectDisconnectEnqueueTimes.current = connectDisconnectEnqueueTimes.current.filter((i) => {\n      const isWithinThreshold =\n        now.getTime() - i.getTime() < CONNECT_DISCONNECT_WARNING_THRESHOLD_MS;\n      if (isWithinThreshold) {\n        connectDisconnectsInThreshold += 1;\n      }\n      return isWithinThreshold;\n    });\n\n    if (connectDisconnectsInThreshold > CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY) {\n      log.warn(\n        `useSequentialRoomConnectDisconnect: room connect / disconnect occurring in rapid sequence (over ${CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY}x in ${CONNECT_DISCONNECT_WARNING_THRESHOLD_MS}ms). This is not recommended and may be the sign of a bug like a useEffect dependency changing every render.`,\n      );\n    }\n  }, []);\n\n  const connect = useCallback(\n    async (...args: Parameters<typeof Room.prototype.connect>) => {\n      return new Promise((resolve, reject) => {\n        if (!room) {\n          throw new Error('Called connect(), but room was unset');\n        }\n        const now = new Date();\n        checkConnectDisconnectThreshold(now);\n        connectDisconnectQueueRef.current.push({ type: 'connect', room, args, resolve, reject });\n        connectDisconnectEnqueueTimes.current.push(now);\n        processConnectsAndDisconnects();\n      });\n    },\n    [room, checkConnectDisconnectThreshold, processConnectsAndDisconnects],\n  );\n\n  const disconnect = useCallback(\n    async (...args: Parameters<typeof Room.prototype.disconnect>) => {\n      return new Promise((resolve, reject) => {\n        if (!room) {\n          throw new Error('Called discconnect(), but room was unset');\n        }\n        const now = new Date();\n        checkConnectDisconnectThreshold(now);\n        connectDisconnectQueueRef.current.push({ type: 'disconnect', room, args, resolve, reject });\n        connectDisconnectEnqueueTimes.current.push(now);\n        processConnectsAndDisconnects();\n      });\n    },\n    [room, checkConnectDisconnectThreshold, processConnectsAndDisconnects],\n  );\n\n  return {\n    connect: room ? connect : null,\n    disconnect: room ? disconnect : null,\n  } as UseSequentialRoomConnectDisconnectResults<R>;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","import {\n  ConnectionState,\n  LocalTrackPublication,\n  ParticipantEvent,\n  ParticipantKind,\n  RemoteParticipant,\n  RoomEvent,\n  Track,\n} from 'livekit-client';\nimport type TypedEventEmitter from 'typed-emitter';\nimport { EventEmitter } from 'events';\nimport * as React from 'react';\nimport { ParticipantAgentAttributes, TrackReference } from '@livekit/components-core';\n\nimport { useParticipantTracks } from './useParticipantTracks';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport { UseSessionReturn } from './useSession';\nimport { useMaybeSessionContext } from '../context';\n\n// FIXME: make this 10 seconds once room dispatch booting info is discoverable\nconst DEFAULT_AGENT_CONNECT_TIMEOUT_MILLISECONDS = 20_000;\n\n/** @see https://github.com/livekit/agents/blob/65170238db197f62f479eb7aaef1c0e18bfad6e7/livekit-agents/livekit/agents/voice/events.py#L97 */\ntype AgentSdkStates = 'initializing' | 'idle' | 'listening' | 'thinking' | 'speaking';\n\n/**\n * State representing the current status of the agent, whether it is ready for speach, etc\n *\n * For most agents (which have the preconnect audio buffer feature enabled), this is the lifecycle:\n *   connecting  pre-connect-buffering  initializing/listening/thinking/speaking\n *\n * For agents without the preconnect audio feature enabled:\n *   connecting  initializing  idle/listening/thinking/speaking\n *\n * If an agent fails to connect:\n *   connecting  pre-connect-buffering/initializing  failed\n *\n * Legacy useVoiceAssistant hook:\n *   disconnected  connecting  initializing  listening/thinking/speaking\n *\n * @beta\n * */\nexport type AgentState =\n  | 'disconnected'\n  | 'connecting'\n  | 'pre-connect-buffering'\n  | 'failed'\n  | AgentSdkStates;\n\n/** @beta */\nexport enum AgentEvent {\n  CameraChanged = 'cameraChanged',\n  MicrophoneChanged = 'microphoneChanged',\n  StateChanged = 'stateChanged',\n}\n\n/** @beta */\nexport type AgentCallbacks = {\n  [AgentEvent.CameraChanged]: (newTrack: TrackReference | undefined) => void;\n  [AgentEvent.MicrophoneChanged]: (newTrack: TrackReference | undefined) => void;\n  [AgentEvent.StateChanged]: (newAgentState: AgentState) => void;\n};\n\ntype AgentStateCommon = {\n  // FIXME: maybe add some sort of schema to this?\n  attributes: Record<string, string>;\n\n  internal: {\n    emitter: TypedEventEmitter<AgentCallbacks>;\n\n    agentParticipant: RemoteParticipant | null;\n    workerParticipant: RemoteParticipant | null;\n  };\n};\n\ntype AgentStateAvailable = AgentStateCommon & {\n  state: 'listening' | 'thinking' | 'speaking';\n  failureReasons: null;\n\n  /** Is the agent connected to the client? */\n  isConnected: true;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: true;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: false;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: false;\n\n  cameraTrack?: TrackReference;\n  microphoneTrack?: TrackReference;\n};\n\ntype AgentStatePreConnectBuffering = AgentStateCommon & {\n  state: 'pre-connect-buffering';\n  failureReasons: null;\n\n  /** Is the agent connected to the client? */\n  isConnected: false;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: true;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: false;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: false;\n\n  cameraTrack?: TrackReference;\n  microphoneTrack?: TrackReference;\n};\n\ntype AgentStateUnAvailable = AgentStateCommon & {\n  state: 'initializing' | 'idle';\n  failureReasons: null;\n\n  /** Is the agent connected to the client? */\n  isConnected: false;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: false;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: false;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: true;\n\n  cameraTrack?: TrackReference;\n  microphoneTrack?: TrackReference;\n};\n\ntype AgentStateConnecting = AgentStateCommon & {\n  state: 'connecting';\n  failureReasons: null;\n\n  /** Is the agent connected to the client? */\n  isConnected: false;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: false;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: false;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: true;\n\n  cameraTrack: undefined;\n  microphoneTrack: undefined;\n};\n\ntype AgentStateDisconnected = AgentStateCommon & {\n  state: 'disconnected';\n  failureReasons: null;\n\n  /** Is the agent connected to the client? */\n  isConnected: false;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: false;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: true;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: false;\n\n  cameraTrack: undefined;\n  microphoneTrack: undefined;\n};\n\ntype AgentStateFailed = AgentStateCommon & {\n  state: 'failed';\n  failureReasons: Array<string>;\n\n  /** Is the agent connected to the client? */\n  isConnected: false;\n\n  /**\n   * Could the client be listening for user speech?\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  canListen: false;\n\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\n  isFinished: true;\n\n  /** Is the agent currently connecting or setting itself up? */\n  isPending: false;\n\n  cameraTrack: undefined;\n  microphoneTrack: undefined;\n};\n\ntype AgentActions = {\n  /** Returns a promise that resolves once the agent is connected and available for user input */\n  waitUntilConnected: (signal?: AbortSignal) => Promise<void>;\n\n  /**\n   * Returns a promise that resolves once the client could be listening for user speech (`canListen` is true)\n   *\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\n   * buffer could be active and recording user input before the agent actually connects.\n   * */\n  waitUntilCouldBeListening: (signal?: AbortSignal) => Promise<void>;\n\n  /** Returns a promise that resolves once the client has disconnected from the agent either for an expected or unexpected reason. */\n  waitUntilFinished: (signal?: AbortSignal) => Promise<void>;\n\n  /** Returns a promise that resolves once the agent has published a camera track */\n  waitUntilCamera: (signal?: AbortSignal) => Promise<TrackReference>;\n\n  /** Returns a promise that resolves once the agent has published a microphone track */\n  waitUntilMicrophone: (signal?: AbortSignal) => Promise<TrackReference>;\n};\n\ntype AgentStateCases =\n  | AgentStateConnecting\n  | AgentStateDisconnected\n  | AgentStateAvailable\n  | AgentStatePreConnectBuffering\n  | AgentStateUnAvailable\n  | AgentStateFailed;\n\n/** @beta */\nexport type UseAgentReturn = AgentStateCases & AgentActions;\n\nconst generateDerivedStateValues = <State extends AgentState>(state: State) =>\n  ({\n    isConnected: state === 'listening' || state === 'thinking' || state === 'speaking',\n    canListen:\n      state === 'pre-connect-buffering' ||\n      state === 'listening' ||\n      state === 'thinking' ||\n      state === 'speaking',\n    isFinished: state === 'disconnected' || state === 'failed',\n    isPending: state === 'connecting' || state === 'initializing' || state === 'idle',\n  }) as {\n    isConnected: State extends 'listening' | 'thinking' | 'speaking' ? true : false;\n    canListen: State extends 'pre-connect-buffering' | 'listening' | 'thinking' | 'speaking'\n      ? true\n      : false;\n    isFinished: State extends 'disconnected' | 'failed' ? true : false;\n    isPending: State extends 'connecting' | 'initializing' | 'idle' ? true : false;\n  };\n\n/** Internal hook used by useSession to store global agent state */\nexport const useAgentTimeoutIdStore = (): {\n  agentTimeoutFailureReason: string | null;\n  startAgentTimeout: (agentConnectTimeoutMilliseconds?: number) => void;\n  clearAgentTimeout: () => void;\n  clearAgentTimeoutFailureReason: () => void;\n  updateAgentTimeoutState: (agentState: AgentState) => void;\n  updateAgentTimeoutParticipantExists: (agentParticipantExists: boolean) => void;\n} => {\n  const [agentTimeoutFailureReason, setAgentTimeoutFailureReason] = React.useState<string | null>(\n    null,\n  );\n  const [agentTimeoutId, setAgentTimeoutId] = React.useState<ReturnType<typeof setTimeout> | null>(\n    null,\n  );\n\n  const agentStateRef = React.useRef<AgentState>('connecting');\n  const agentParticipantExistsRef = React.useRef(false);\n\n  const startAgentConnectedTimeout = (agentConnectTimeoutMilliseconds?: number) => {\n    return setTimeout(() => {\n      if (!agentParticipantExistsRef.current) {\n        setAgentTimeoutFailureReason('Agent did not join the room.');\n        return;\n      }\n\n      const { isConnected } = generateDerivedStateValues(agentStateRef.current);\n      if (!isConnected) {\n        setAgentTimeoutFailureReason('Agent joined the room but did not complete initializing.');\n        return;\n      }\n    }, agentConnectTimeoutMilliseconds ?? DEFAULT_AGENT_CONNECT_TIMEOUT_MILLISECONDS);\n  };\n\n  return {\n    agentTimeoutFailureReason,\n    startAgentTimeout: React.useCallback(\n      (agentConnectTimeoutMilliseconds?: number) => {\n        if (agentTimeoutId) {\n          clearTimeout(agentTimeoutId);\n        }\n\n        setAgentTimeoutFailureReason(null);\n        setAgentTimeoutId(startAgentConnectedTimeout(agentConnectTimeoutMilliseconds));\n        agentStateRef.current = 'connecting';\n        agentParticipantExistsRef.current = false;\n      },\n      [agentTimeoutId],\n    ),\n    clearAgentTimeout: React.useCallback(() => {\n      if (agentTimeoutId) {\n        clearTimeout(agentTimeoutId);\n      }\n\n      setAgentTimeoutFailureReason(null);\n      setAgentTimeoutId(null);\n      agentStateRef.current = 'connecting';\n      agentParticipantExistsRef.current = false;\n    }, [agentTimeoutId]),\n    clearAgentTimeoutFailureReason: React.useCallback(() => {\n      setAgentTimeoutFailureReason(null);\n    }, []),\n\n    updateAgentTimeoutState: React.useCallback((agentState: AgentState) => {\n      agentStateRef.current = agentState;\n    }, []),\n    updateAgentTimeoutParticipantExists: React.useCallback((agentParticipantExists: boolean) => {\n      agentParticipantExistsRef.current = agentParticipantExists;\n    }, []),\n  };\n};\n\ntype SessionStub = Pick<UseSessionReturn, 'connectionState' | 'room' | 'internal'>;\n\n/** Internal hook used by useAgent which generates a function that when called, will return a\n * promise which resolves when agent.isAvailable is enabled. */\nfunction useAgentWaitUntilDerivedStates(\n  emitter: TypedEventEmitter<AgentCallbacks>,\n  state: AgentState,\n) {\n  const stateRef = React.useRef(state);\n  React.useEffect(() => {\n    stateRef.current = state;\n  }, [state]);\n\n  const waitUntilConnected = React.useCallback(\n    async (signal?: AbortSignal) => {\n      const { isConnected } = generateDerivedStateValues(stateRef.current);\n      if (isConnected) {\n        return;\n      }\n\n      return new Promise<void>((resolve, reject) => {\n        const stateChangedHandler = (state: AgentState) => {\n          const { isConnected } = generateDerivedStateValues(state);\n          if (!isConnected) {\n            return;\n          }\n          cleanup();\n          resolve();\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(new Error('useAgent(/* ... */).waitUntilConnected - signal aborted'));\n        };\n\n        const cleanup = () => {\n          emitter.off(AgentEvent.StateChanged, stateChangedHandler);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(AgentEvent.StateChanged, stateChangedHandler);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  const waitUntilCouldBeListening = React.useCallback(\n    async (signal?: AbortSignal) => {\n      const { canListen } = generateDerivedStateValues(stateRef.current);\n      if (canListen) {\n        return;\n      }\n\n      return new Promise<void>((resolve, reject) => {\n        const stateChangedHandler = (state: AgentState) => {\n          const { canListen } = generateDerivedStateValues(state);\n          if (!canListen) {\n            return;\n          }\n          cleanup();\n          resolve();\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(new Error('useAgent(/* ... */).waitUntilCouldBeListening - signal aborted'));\n        };\n\n        const cleanup = () => {\n          emitter.off(AgentEvent.StateChanged, stateChangedHandler);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(AgentEvent.StateChanged, stateChangedHandler);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  const waitUntilFinished = React.useCallback(\n    async (signal?: AbortSignal) => {\n      const { isFinished } = generateDerivedStateValues(stateRef.current);\n      if (isFinished) {\n        return;\n      }\n\n      return new Promise<void>((resolve, reject) => {\n        const stateChangedHandler = (state: AgentState) => {\n          const { isFinished } = generateDerivedStateValues(state);\n          if (!isFinished) {\n            return;\n          }\n          cleanup();\n          resolve();\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(new Error('useAgent(/* ... */).waitUntilFinished - signal aborted'));\n        };\n\n        const cleanup = () => {\n          emitter.off(AgentEvent.StateChanged, stateChangedHandler);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(AgentEvent.StateChanged, stateChangedHandler);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  return { waitUntilConnected, waitUntilCouldBeListening, waitUntilFinished };\n}\n\n/**\n * useAgent encapculates all agent state, normalizing some quirks around how LiveKit Agents work.\n * @beta\n */\nexport function useAgent(session?: SessionStub): UseAgentReturn {\n  const sessionFromContext = useMaybeSessionContext();\n  session = session ?? sessionFromContext;\n  if (!session) {\n    throw new Error(\n      'No session provided, make sure you are inside a Session context or pass the session explicitly',\n    );\n  }\n\n  const {\n    room,\n    internal: {\n      agentConnectTimeoutMilliseconds,\n\n      agentTimeoutFailureReason,\n      startAgentTimeout,\n      clearAgentTimeout,\n      clearAgentTimeoutFailureReason,\n      updateAgentTimeoutState,\n      updateAgentTimeoutParticipantExists,\n    },\n  } = session;\n\n  const emitter = React.useMemo(() => new EventEmitter() as TypedEventEmitter<AgentCallbacks>, []);\n\n  const roomRemoteParticipants = useRemoteParticipants({ room });\n\n  const agentParticipant = React.useMemo(() => {\n    return (\n      roomRemoteParticipants.find(\n        (p) =>\n          p.kind === ParticipantKind.AGENT &&\n          !(ParticipantAgentAttributes.PublishOnBehalf in p.attributes),\n      ) ?? null\n    );\n  }, [roomRemoteParticipants]);\n  const workerParticipant = React.useMemo(() => {\n    if (!agentParticipant) {\n      return null;\n    }\n    return (\n      roomRemoteParticipants.find(\n        (p) =>\n          p.kind === ParticipantKind.AGENT &&\n          p.attributes[ParticipantAgentAttributes.PublishOnBehalf] === agentParticipant.identity,\n      ) ?? null\n    );\n  }, [agentParticipant, roomRemoteParticipants]);\n\n  // 1. Listen for agent participant attribute changes\n  const [agentParticipantAttributes, setAgentParticipantAttributes] = React.useState<\n    Record<string, string>\n  >({});\n  React.useEffect(() => {\n    if (!agentParticipant) {\n      return;\n    }\n\n    const handleAttributesChanged = (attributes: UseAgentReturn['attributes']) => {\n      setAgentParticipantAttributes(attributes);\n    };\n\n    agentParticipant.on(ParticipantEvent.AttributesChanged, handleAttributesChanged);\n    return () => {\n      agentParticipant.off(ParticipantEvent.AttributesChanged, handleAttributesChanged);\n    };\n  }, [agentParticipant, emitter]);\n\n  // 2. Listen for track updates\n  const agentTracks = useParticipantTracks([Track.Source.Camera, Track.Source.Microphone], {\n    room,\n    participantIdentity: agentParticipant?.identity,\n  });\n  const workerTracks = useParticipantTracks([Track.Source.Camera, Track.Source.Microphone], {\n    room,\n    participantIdentity: workerParticipant?.identity,\n  });\n\n  const videoTrack = React.useMemo(\n    () =>\n      agentTracks.find((t) => t.source === Track.Source.Camera) ??\n      workerTracks.find((t) => t.source === Track.Source.Camera),\n    [agentTracks, workerTracks],\n  );\n  React.useEffect(() => {\n    emitter.emit(AgentEvent.CameraChanged, videoTrack);\n  }, [emitter, videoTrack]);\n\n  const audioTrack = React.useMemo(\n    () =>\n      agentTracks.find((t) => t.source === Track.Source.Microphone) ??\n      workerTracks.find((t) => t.source === Track.Source.Microphone),\n    [agentTracks, workerTracks],\n  );\n  React.useEffect(() => {\n    emitter.emit(AgentEvent.MicrophoneChanged, audioTrack);\n  }, [emitter, audioTrack]);\n\n  // Listen for room connection state updates\n  const [roomConnectionState, setRoomConnectionState] = React.useState(room.state);\n  React.useEffect(() => {\n    const handleConnectionStateChanged = (connectionState: ConnectionState) => {\n      setRoomConnectionState(connectionState);\n    };\n\n    room.on(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\n    return () => {\n      room.off(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\n    };\n  }, [room]);\n\n  // When the agent participant connects, reset the timeout failure state\n  React.useEffect(() => {\n    if (!agentParticipant) {\n      return;\n    }\n\n    clearAgentTimeoutFailureReason();\n  }, [agentParticipant]);\n\n  // If the agent participant disconnects in the middle of a conversation unexpectedly, mark that as an explicit failure\n  const [agentDisconnectedFailureReason, setAgentDisconnectedFailureReason] = React.useState<\n    string | null\n  >(null);\n  React.useEffect(() => {\n    if (!agentParticipant) {\n      return;\n    }\n\n    const onParticipantDisconnect = (participant: RemoteParticipant) => {\n      if (participant.identity !== agentParticipant?.identity) {\n        return;\n      }\n      setAgentDisconnectedFailureReason('Agent left the room unexpectedly.');\n    };\n\n    room.on(RoomEvent.ParticipantDisconnected, onParticipantDisconnect);\n\n    return () => {\n      room.off(RoomEvent.ParticipantDisconnected, onParticipantDisconnect);\n    };\n  }, [agentParticipant, room]);\n\n  React.useEffect(() => {\n    if (roomConnectionState !== ConnectionState.Disconnected) {\n      return;\n    }\n    // Clear the agent disconnect failure state when the room disconnects\n    setAgentDisconnectedFailureReason(null);\n  }, [roomConnectionState]);\n\n  const [localMicTrack, setLocalMicTrack] = React.useState<LocalTrackPublication | null>(\n    () => room.localParticipant.getTrackPublication(Track.Source.Microphone) ?? null,\n  );\n  React.useEffect(() => {\n    const handleLocalParticipantTrackPublished = () => {\n      setLocalMicTrack(room.localParticipant.getTrackPublication(Track.Source.Microphone) ?? null);\n    };\n    const handleLocalParticipantTrackUnPublished = () => {\n      setLocalMicTrack(null);\n    };\n\n    room.localParticipant.on(\n      ParticipantEvent.LocalTrackPublished,\n      handleLocalParticipantTrackPublished,\n    );\n    room.localParticipant.on(\n      ParticipantEvent.LocalTrackUnpublished,\n      handleLocalParticipantTrackUnPublished,\n    );\n    return () => {\n      room.localParticipant.off(\n        ParticipantEvent.LocalTrackPublished,\n        handleLocalParticipantTrackPublished,\n      );\n      room.localParticipant.off(\n        ParticipantEvent.LocalTrackUnpublished,\n        handleLocalParticipantTrackUnPublished,\n      );\n    };\n  }, [room.localParticipant]);\n\n  const failureReasons = React.useMemo(() => {\n    const reasons = [];\n    if (agentTimeoutFailureReason) {\n      reasons.push(agentTimeoutFailureReason);\n    }\n    if (agentDisconnectedFailureReason) {\n      reasons.push(agentDisconnectedFailureReason);\n    }\n    return reasons;\n  }, [agentTimeoutFailureReason, agentDisconnectedFailureReason]);\n\n  const state = React.useMemo(() => {\n    if (failureReasons.length > 0) {\n      return 'failed';\n    }\n\n    let state: AgentState = 'disconnected';\n\n    if (roomConnectionState !== ConnectionState.Disconnected) {\n      state = 'connecting';\n    }\n\n    // If the microphone preconnect buffer is active, then a special 'pre-connect-buffering' state\n    // is set\n    if (localMicTrack) {\n      state = 'pre-connect-buffering';\n    }\n\n    if (agentParticipant && agentParticipantAttributes[ParticipantAgentAttributes.AgentState]) {\n      state = agentParticipantAttributes[ParticipantAgentAttributes.AgentState] as AgentSdkStates;\n    }\n\n    return state;\n  }, [\n    failureReasons,\n    roomConnectionState,\n    localMicTrack,\n    agentParticipant,\n    agentParticipantAttributes,\n  ]);\n\n  React.useEffect(() => {\n    emitter.emit(AgentEvent.StateChanged, state);\n    updateAgentTimeoutState(state);\n  }, [emitter, state]);\n  React.useEffect(() => {\n    updateAgentTimeoutParticipantExists(agentParticipant !== null);\n  }, [agentParticipant]);\n\n  // When the session room begins connecting, start the agent timeout\n  const isSessionDisconnected = session.connectionState === 'disconnected';\n  React.useEffect(() => {\n    if (isSessionDisconnected) {\n      return;\n    }\n\n    startAgentTimeout(agentConnectTimeoutMilliseconds);\n    return () => {\n      clearAgentTimeout();\n    };\n  }, [isSessionDisconnected, agentConnectTimeoutMilliseconds]);\n\n  const agentState: AgentStateCases = React.useMemo(() => {\n    const common: AgentStateCommon = {\n      attributes: agentParticipantAttributes,\n\n      internal: {\n        agentParticipant,\n        workerParticipant,\n        emitter,\n      },\n    };\n\n    switch (state) {\n      case 'disconnected':\n        return {\n          ...common,\n\n          state,\n          ...generateDerivedStateValues(state),\n          failureReasons: null,\n\n          // Clear inner values if no longer connected\n          cameraTrack: undefined,\n          microphoneTrack: undefined,\n        };\n\n      case 'connecting':\n        return {\n          ...common,\n\n          state,\n          ...generateDerivedStateValues(state),\n          failureReasons: null,\n\n          // Clear inner values if no longer connected\n          cameraTrack: undefined,\n          microphoneTrack: undefined,\n        };\n\n      case 'initializing':\n      case 'idle':\n        return {\n          ...common,\n\n          state,\n          ...generateDerivedStateValues(state),\n          failureReasons: null,\n\n          cameraTrack: videoTrack,\n          microphoneTrack: audioTrack,\n        };\n\n      case 'pre-connect-buffering':\n        return {\n          ...common,\n\n          state,\n          ...generateDerivedStateValues(state),\n          failureReasons: null,\n\n          cameraTrack: videoTrack,\n          microphoneTrack: audioTrack,\n        };\n\n      case 'listening':\n      case 'thinking':\n      case 'speaking':\n        return {\n          ...common,\n\n          state,\n          ...generateDerivedStateValues(state),\n          failureReasons: null,\n\n          cameraTrack: videoTrack,\n          microphoneTrack: audioTrack,\n        };\n\n      case 'failed':\n        return {\n          ...common,\n\n          state: 'failed',\n          ...generateDerivedStateValues('failed'),\n          failureReasons,\n\n          // Clear inner values if no longer connected\n          cameraTrack: undefined,\n          microphoneTrack: undefined,\n        };\n    }\n  }, [agentParticipantAttributes, emitter, agentParticipant, state, videoTrack, audioTrack]);\n\n  const { waitUntilConnected, waitUntilCouldBeListening, waitUntilFinished } =\n    useAgentWaitUntilDerivedStates(emitter, state);\n\n  const waitUntilCamera = React.useCallback(\n    (signal?: AbortSignal) => {\n      return new Promise<TrackReference>((resolve, reject) => {\n        const stateChangedHandler = (camera: TrackReference | undefined) => {\n          if (!camera) {\n            return;\n          }\n          cleanup();\n          resolve(camera);\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(new Error('useAgent(/* ... */).waitUntilCamera - signal aborted'));\n        };\n\n        const cleanup = () => {\n          emitter.off(AgentEvent.CameraChanged, stateChangedHandler);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(AgentEvent.CameraChanged, stateChangedHandler);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  const waitUntilMicrophone = React.useCallback(\n    (signal?: AbortSignal) => {\n      return new Promise<TrackReference>((resolve, reject) => {\n        const stateChangedHandler = (microphone: TrackReference | undefined) => {\n          if (!microphone) {\n            return;\n          }\n          cleanup();\n          resolve(microphone);\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(new Error('useAgent(/* ... */).waitUntilMicrophone - signal aborted'));\n        };\n\n        const cleanup = () => {\n          emitter.off(AgentEvent.MicrophoneChanged, stateChangedHandler);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(AgentEvent.MicrophoneChanged, stateChangedHandler);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  return React.useMemo(() => {\n    return {\n      ...agentState,\n      waitUntilConnected,\n      waitUntilCouldBeListening,\n      waitUntilFinished,\n      waitUntilCamera,\n      waitUntilMicrophone,\n    };\n  }, [\n    agentState,\n    waitUntilConnected,\n    waitUntilCouldBeListening,\n    waitUntilFinished,\n    waitUntilCamera,\n    waitUntilMicrophone,\n  ]);\n}\n","import * as React from 'react';\nimport type TypedEventEmitter from 'typed-emitter';\nimport {\n  Room,\n  RoomEvent,\n  ConnectionState,\n  TrackPublishOptions,\n  Track,\n  TokenSourceConfigurable,\n  TokenSourceFixed,\n  TokenSourceFetchOptions,\n  RoomConnectOptions,\n  decodeTokenPayload,\n} from 'livekit-client';\nimport { EventEmitter } from 'events';\n\nimport { useMaybeRoomContext } from '../context';\nimport { AgentState, useAgent, useAgentTimeoutIdStore } from './useAgent';\nimport { TrackReference } from '@livekit/components-core';\nimport { useLocalParticipant } from './useLocalParticipant';\n\n/** @beta */\nexport enum SessionEvent {\n  ConnectionStateChanged = 'connectionStateChanged',\n  /**\n   * Emits when an error is encountered while attempting to create a track.\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\n   * args: (error: Error, kind: MediaDeviceKind)\n   */\n  MediaDevicesError = 'mediaDevicesError',\n  /**\n   * Emits when an error is received while decrypting frame received frame information.\n   * args: (error: Error)\n   */\n  EncryptionError = 'encryptionError',\n}\n\n/** @beta */\nexport type SessionCallbacks = {\n  [SessionEvent.ConnectionStateChanged]: (newAgentConnectionState: ConnectionState) => void;\n  [SessionEvent.MediaDevicesError]: (error: Error) => void;\n  [SessionEvent.EncryptionError]: (error: Error) => void;\n};\n\n/** @beta */\nexport type SessionConnectOptions = {\n  /** Optional abort signal which if triggered will terminate connecting even if it isn't complete */\n  signal?: AbortSignal;\n\n  tracks?: {\n    microphone?: {\n      enabled?: boolean;\n      publishOptions?: TrackPublishOptions;\n    };\n  };\n\n  /** Options for Room.connect(.., .., opts) */\n  roomConnectOptions?: RoomConnectOptions;\n};\n\n/** @beta */\nexport type SwitchActiveDeviceOptions = {\n  /**\n   *  If true, adds an `exact` constraint to the getUserMedia request.\n   *  The request will fail if this option is true and the device specified is not actually available\n   */\n  exact?: boolean;\n};\n\ntype SessionStateCommon = {\n  room: Room;\n  internal: {\n    emitter: TypedEventEmitter<SessionCallbacks>;\n    tokenSource: TokenSourceConfigurable | TokenSourceFixed;\n    agentConnectTimeoutMilliseconds?: number;\n\n    agentTimeoutFailureReason: string | null;\n    startAgentTimeout: (agentConnectTimeoutMilliseconds?: number) => void;\n    clearAgentTimeout: () => void;\n    clearAgentTimeoutFailureReason: () => void;\n    updateAgentTimeoutState: (agentState: AgentState) => void;\n    updateAgentTimeoutParticipantExists: (agentParticipantExists: boolean) => void;\n  };\n};\n\ntype SessionStateConnecting = SessionStateCommon & {\n  connectionState: ConnectionState.Connecting;\n  isConnected: false;\n\n  local: {\n    cameraTrack: null;\n    microphoneTrack: null;\n  };\n};\n\ntype SessionStateConnected = SessionStateCommon & {\n  connectionState:\n    | ConnectionState.Connected\n    | ConnectionState.Reconnecting\n    | ConnectionState.SignalReconnecting;\n  isConnected: true;\n\n  local: {\n    cameraTrack: TrackReference | null;\n    microphoneTrack: TrackReference | null;\n  };\n};\n\ntype SessionStateDisconnected = SessionStateCommon & {\n  connectionState: ConnectionState.Disconnected;\n  isConnected: false;\n\n  local: {\n    cameraTrack: null;\n    microphoneTrack: null;\n  };\n};\n\ntype SessionActions = {\n  /** Returns a promise that resolves once the room connects. */\n  waitUntilConnected: (signal?: AbortSignal) => void;\n  /** Returns a promise that resolves once the room disconnects */\n  waitUntilDisconnected: (signal?: AbortSignal) => void;\n\n  prepareConnection: () => Promise<void>;\n\n  /** Connect to the underlying room and dispatch any agents */\n  start: (options?: SessionConnectOptions) => Promise<void>;\n\n  /** Disconnect from the underlying room */\n  end: () => Promise<void>;\n};\n\n/** @beta */\nexport type UseSessionReturn = (\n  | SessionStateConnecting\n  | SessionStateConnected\n  | SessionStateDisconnected\n) &\n  SessionActions;\n\ntype UseSessionCommonOptions = {\n  room?: Room;\n\n  /**\n   * Amount of time in milliseonds the system will wait for an agent to join the room, before\n   * transitioning to the \"failure\" state.\n   */\n  agentConnectTimeoutMilliseconds?: number;\n};\n\ntype UseSessionConfigurableOptions = UseSessionCommonOptions & TokenSourceFetchOptions;\ntype UseSessionFixedOptions = UseSessionCommonOptions;\n\n/**\n * Given two TokenSourceFetchOptions values, check to see if they are deep equal.\n *\n * FIXME: swap this for an import from livekit-client once\n * https://github.com/livekit/client-sdk-js/pull/1733 is merged and published!\n * */\nfunction areTokenSourceFetchOptionsEqual(a: TokenSourceFetchOptions, b: TokenSourceFetchOptions) {\n  const allKeysSet = new Set([...Object.keys(a), ...Object.keys(b)]) as Set<\n    keyof TokenSourceFetchOptions\n  >;\n\n  for (const key of allKeysSet) {\n    switch (key) {\n      case 'roomName':\n      case 'participantName':\n      case 'participantIdentity':\n      case 'participantMetadata':\n      case 'participantAttributes':\n      case 'agentName':\n      case 'agentMetadata':\n        if (a[key] !== b[key]) {\n          return false;\n        }\n        break;\n      default:\n        // ref: https://stackoverflow.com/a/58009992\n        const exhaustiveCheckedKey: never = key;\n        throw new Error(`Options key ${exhaustiveCheckedKey} not being checked for equality!`);\n    }\n  }\n\n  return true;\n}\n\n/** Internal hook used by useSession to manage creating a function which can be used to wait\n * until the session is in a given state before resolving. */\nfunction useSessionWaitUntilConnectionState(\n  emitter: TypedEventEmitter<SessionCallbacks>,\n  connectionState: UseSessionReturn['connectionState'],\n) {\n  const connectionStateRef = React.useRef(connectionState);\n  React.useEffect(() => {\n    connectionStateRef.current = connectionState;\n  }, [connectionState]);\n\n  const waitUntilConnectionState = React.useCallback(\n    async (state: UseSessionReturn['connectionState'], signal?: AbortSignal) => {\n      if (connectionStateRef.current === state) {\n        return;\n      }\n\n      return new Promise<void>((resolve, reject) => {\n        const onceEventOccurred = (newState: UseSessionReturn['connectionState']) => {\n          if (newState !== state) {\n            return;\n          }\n          cleanup();\n          resolve();\n        };\n        const abortHandler = () => {\n          cleanup();\n          reject(\n            new Error(\n              `useSession(/* ... */).waitUntilConnectionState(${state}, /* signal */) - signal aborted`,\n            ),\n          );\n        };\n\n        const cleanup = () => {\n          emitter.off(SessionEvent.ConnectionStateChanged, onceEventOccurred);\n          signal?.removeEventListener('abort', abortHandler);\n        };\n\n        emitter.on(SessionEvent.ConnectionStateChanged, onceEventOccurred);\n        signal?.addEventListener('abort', abortHandler);\n      });\n    },\n    [emitter],\n  );\n\n  return waitUntilConnectionState;\n}\n\n/** Internal hook used by useSession to manage creating a function that properly invokes\n * tokenSource.fetch(...) with any fetch options */\nfunction useSessionTokenSourceFetch(\n  tokenSource: TokenSourceConfigurable | TokenSourceFixed,\n  unstableRestOptions: Exclude<UseSessionConfigurableOptions, keyof UseSessionCommonOptions>,\n) {\n  const isConfigurable = tokenSource instanceof TokenSourceConfigurable;\n\n  const memoizedTokenFetchOptionsRef = React.useRef<TokenSourceFetchOptions | null>(\n    isConfigurable ? unstableRestOptions : null,\n  );\n\n  React.useEffect(() => {\n    if (!isConfigurable) {\n      memoizedTokenFetchOptionsRef.current = null;\n      return;\n    }\n\n    if (\n      memoizedTokenFetchOptionsRef.current !== null &&\n      areTokenSourceFetchOptionsEqual(memoizedTokenFetchOptionsRef.current, unstableRestOptions)\n    ) {\n      return;\n    }\n\n    memoizedTokenFetchOptionsRef.current = unstableRestOptions;\n  }, [isConfigurable, unstableRestOptions]);\n\n  const tokenSourceFetch = React.useCallback(async () => {\n    if (isConfigurable) {\n      if (!memoizedTokenFetchOptionsRef.current) {\n        throw new Error(\n          `AgentSession - memoized token fetch options are not set, but the passed tokenSource was an instance of TokenSourceConfigurable. If you are seeing this please make a new GitHub issue!`,\n        );\n      }\n      return tokenSource.fetch(memoizedTokenFetchOptionsRef.current);\n    } else {\n      return tokenSource.fetch();\n    }\n  }, [isConfigurable, tokenSource]);\n\n  return tokenSourceFetch;\n}\n\n/**\n * A Session represents a managed connection to a Room which can contain Agents.\n * @beta\n */\nexport function useSession(\n  tokenSource: TokenSourceConfigurable,\n  options?: UseSessionConfigurableOptions,\n): UseSessionReturn;\n/**\n * A Session represents a managed connection to a Room which can contain Agents.\n * @beta\n */\nexport function useSession(\n  tokenSource: TokenSourceFixed,\n  options?: UseSessionFixedOptions,\n): UseSessionReturn;\nexport function useSession(\n  tokenSource: TokenSourceConfigurable | TokenSourceFixed,\n  options: UseSessionConfigurableOptions | UseSessionFixedOptions = {},\n): UseSessionReturn {\n  const { room: optionsRoom, agentConnectTimeoutMilliseconds, ...restOptions } = options;\n\n  const roomFromContext = useMaybeRoomContext();\n  const room = React.useMemo(\n    () => roomFromContext ?? optionsRoom ?? new Room(),\n    [roomFromContext, optionsRoom],\n  );\n\n  const emitter = React.useMemo(\n    () => new EventEmitter() as TypedEventEmitter<SessionCallbacks>,\n    [],\n  );\n\n  const generateDerivedConnectionStateValues = React.useCallback(\n    <State extends UseSessionReturn['connectionState']>(connectionState: State) =>\n      ({\n        isConnected:\n          connectionState === ConnectionState.Connected ||\n          connectionState === ConnectionState.Reconnecting ||\n          connectionState === ConnectionState.SignalReconnecting,\n      }) as {\n        isConnected: State extends\n          | ConnectionState.Connected\n          | ConnectionState.Reconnecting\n          | ConnectionState.SignalReconnecting\n          ? true\n          : false;\n      },\n    [],\n  );\n\n  const [roomConnectionState, setRoomConnectionState] = React.useState(room.state);\n  React.useEffect(() => {\n    const handleConnectionStateChanged = (connectionState: ConnectionState) => {\n      setRoomConnectionState(connectionState);\n    };\n\n    room.on(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\n    return () => {\n      room.off(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\n    };\n  }, [room]);\n\n  React.useEffect(() => {\n    const handleMediaDevicesError = async (error: Error) => {\n      emitter.emit(SessionEvent.MediaDevicesError, error);\n    };\n\n    room.on(RoomEvent.MediaDevicesError, handleMediaDevicesError);\n    return () => {\n      room.off(RoomEvent.MediaDevicesError, handleMediaDevicesError);\n    };\n  }, [room, emitter]);\n\n  React.useEffect(() => {\n    const handleEncryptionError = async (error: Error) => {\n      emitter.emit(SessionEvent.EncryptionError, error);\n    };\n\n    room.on(RoomEvent.EncryptionError, handleEncryptionError);\n    return () => {\n      room.off(RoomEvent.EncryptionError, handleEncryptionError);\n    };\n  }, [room, emitter]);\n\n  const { localParticipant } = useLocalParticipant({ room });\n  const cameraPublication = localParticipant.getTrackPublication(Track.Source.Camera);\n  const localCamera = React.useMemo(() => {\n    if (!cameraPublication || cameraPublication.isMuted) {\n      return null;\n    }\n    return {\n      source: Track.Source.Camera,\n      participant: localParticipant,\n      publication: cameraPublication,\n    };\n  }, [localParticipant, cameraPublication, cameraPublication?.isMuted]);\n  const microphonePublication = localParticipant.getTrackPublication(Track.Source.Microphone);\n  const localMicrophone = React.useMemo(() => {\n    if (!microphonePublication || microphonePublication.isMuted) {\n      return null;\n    }\n    return {\n      source: Track.Source.Microphone,\n      participant: localParticipant,\n      publication: microphonePublication,\n    };\n  }, [localParticipant, microphonePublication, microphonePublication?.isMuted]);\n\n  const {\n    agentTimeoutFailureReason,\n    startAgentTimeout,\n    clearAgentTimeout,\n    clearAgentTimeoutFailureReason,\n    updateAgentTimeoutState,\n    updateAgentTimeoutParticipantExists,\n  } = useAgentTimeoutIdStore();\n\n  const sessionInternal: UseSessionReturn['internal'] = React.useMemo(\n    () => ({\n      emitter,\n      tokenSource,\n      agentConnectTimeoutMilliseconds,\n\n      agentTimeoutFailureReason,\n      startAgentTimeout,\n      clearAgentTimeout,\n      clearAgentTimeoutFailureReason,\n      updateAgentTimeoutState,\n      updateAgentTimeoutParticipantExists,\n    }),\n    [\n      emitter,\n      agentConnectTimeoutMilliseconds,\n      tokenSource,\n      agentTimeoutFailureReason,\n      startAgentTimeout,\n      clearAgentTimeout,\n      clearAgentTimeoutFailureReason,\n      updateAgentTimeoutState,\n      updateAgentTimeoutParticipantExists,\n    ],\n  );\n\n  const conversationState = React.useMemo(():\n    | SessionStateConnecting\n    | SessionStateConnected\n    | SessionStateDisconnected => {\n    const common: SessionStateCommon = {\n      room,\n      internal: sessionInternal,\n    };\n\n    switch (roomConnectionState) {\n      case ConnectionState.Connecting:\n        return {\n          ...common,\n\n          connectionState: ConnectionState.Connecting,\n          ...generateDerivedConnectionStateValues(ConnectionState.Connecting),\n\n          local: {\n            cameraTrack: null,\n            microphoneTrack: null,\n          },\n        };\n\n      case ConnectionState.Connected:\n      case ConnectionState.Reconnecting:\n      case ConnectionState.SignalReconnecting:\n        return {\n          ...common,\n\n          connectionState: roomConnectionState,\n          ...generateDerivedConnectionStateValues(roomConnectionState),\n\n          local: {\n            cameraTrack: localCamera,\n            microphoneTrack: localMicrophone,\n          },\n        };\n\n      case ConnectionState.Disconnected:\n        return {\n          ...common,\n\n          connectionState: ConnectionState.Disconnected,\n          ...generateDerivedConnectionStateValues(ConnectionState.Disconnected),\n\n          local: {\n            cameraTrack: null,\n            microphoneTrack: null,\n          },\n        };\n    }\n  }, [\n    sessionInternal,\n    room,\n    roomConnectionState,\n    localCamera,\n    localMicrophone,\n    generateDerivedConnectionStateValues,\n  ]);\n  React.useEffect(() => {\n    emitter.emit(SessionEvent.ConnectionStateChanged, conversationState.connectionState);\n  }, [emitter, conversationState.connectionState]);\n\n  const waitUntilConnectionState = useSessionWaitUntilConnectionState(\n    emitter,\n    conversationState.connectionState,\n  );\n\n  const waitUntilConnected = React.useCallback(\n    async (signal?: AbortSignal) => {\n      return waitUntilConnectionState(\n        ConnectionState.Connected /* FIXME: should I check for other states too? */,\n        signal,\n      );\n    },\n    [waitUntilConnectionState],\n  );\n\n  const waitUntilDisconnected = React.useCallback(\n    async (signal?: AbortSignal) => {\n      return waitUntilConnectionState(ConnectionState.Disconnected, signal);\n    },\n    [waitUntilConnectionState],\n  );\n\n  const agent = useAgent(\n    React.useMemo(\n      () => ({\n        connectionState: conversationState.connectionState,\n        room,\n        internal: sessionInternal,\n      }),\n      [conversationState, room, sessionInternal],\n    ),\n  );\n\n  const tokenSourceFetch = useSessionTokenSourceFetch(tokenSource, restOptions);\n\n  const start = React.useCallback(\n    async (connectOptions: SessionConnectOptions = {}) => {\n      const {\n        signal,\n        tracks = { microphone: { enabled: true, publishOptions: { preConnectBuffer: true } } },\n        roomConnectOptions,\n      } = connectOptions;\n\n      await waitUntilDisconnected(signal);\n\n      const onSignalAbort = () => {\n        room.disconnect();\n      };\n      signal?.addEventListener('abort', onSignalAbort);\n\n      let tokenDispatchesAgent = false;\n      await Promise.all([\n        tokenSourceFetch().then(({ serverUrl, participantToken }) => {\n          const participantTokenPayload = decodeTokenPayload(participantToken);\n          const participantTokenAgentDispatchCount =\n            participantTokenPayload.roomConfig?.agents?.length ?? 0;\n          tokenDispatchesAgent = participantTokenAgentDispatchCount > 0;\n\n          return room.connect(serverUrl, participantToken, roomConnectOptions);\n        }),\n\n        // Start microphone (with preconnect buffer) by default\n        tracks.microphone?.enabled\n          ? room.localParticipant.setMicrophoneEnabled(\n              true,\n              undefined,\n              tracks.microphone?.publishOptions ?? {},\n            )\n          : Promise.resolve(),\n      ]);\n\n      await waitUntilConnected(signal);\n      if (tokenDispatchesAgent) {\n        await agent.waitUntilConnected(signal);\n      }\n\n      signal?.removeEventListener('abort', onSignalAbort);\n    },\n    [room, waitUntilDisconnected, tokenSourceFetch, waitUntilConnected, agent.waitUntilConnected],\n  );\n\n  const end = React.useCallback(async () => {\n    await room.disconnect();\n  }, [room]);\n\n  const prepareConnection = React.useCallback(async () => {\n    const credentials = await tokenSourceFetch();\n    await room.prepareConnection(credentials.serverUrl, credentials.participantToken);\n  }, [tokenSourceFetch, room]);\n  React.useEffect(\n    () => {\n      prepareConnection().catch((err) => {\n        // FIXME: figure out a better logging solution?\n        console.warn('WARNING: Room.prepareConnection failed:', err);\n      });\n    },\n    [\n      /* note: no prepareConnection here, this effect should only ever run once! */\n    ],\n  );\n\n  return React.useMemo(\n    () => ({\n      ...conversationState,\n\n      waitUntilConnected,\n      waitUntilDisconnected,\n\n      prepareConnection,\n      start,\n      end,\n    }),\n    [conversationState, waitUntilConnected, waitUntilDisconnected, prepareConnection, start, end],\n  );\n}\n","import * as React from 'react';\nimport TypedEventEmitter, { EventMap } from 'typed-emitter';\n\n/** @public */\nexport function useEvents<\n  Emitter extends TypedEventEmitter<EventMap>,\n  EmitterEventMap extends Emitter extends TypedEventEmitter<infer EM> ? EM : never,\n  Event extends Parameters<Emitter['on']>[0],\n  Callback extends EmitterEventMap[Event],\n>(\n  instance: Emitter | { internal: { emitter: Emitter } } | null | undefined,\n  event: Event,\n  handlerFn: Callback | undefined,\n  dependencies?: React.DependencyList,\n) {\n  const fallback = React.useMemo(() => () => {}, []);\n  const wrappedCallback = React.useCallback(handlerFn ?? fallback, dependencies ?? []);\n  const callback = dependencies ? wrappedCallback : handlerFn;\n\n  const emitter = React.useMemo(() => {\n    if (!instance) {\n      return null;\n    }\n    if ('internal' in instance) {\n      return instance.internal.emitter;\n    }\n    return instance;\n  }, [instance]);\n\n  React.useEffect(() => {\n    if (!emitter || !callback) {\n      return;\n    }\n    emitter.on(event, callback);\n    return () => {\n      emitter.off(event, callback);\n    };\n  }, [emitter, event, callback]);\n}\n","import * as React from 'react';\nimport type TypedEventEmitter from 'typed-emitter';\nimport { SendTextOptions } from 'livekit-client';\nimport { EventEmitter } from 'events';\nimport {\n  ReceivedMessage,\n  ReceivedChatMessage,\n  TextStreamData,\n  ReceivedUserTranscriptionMessage,\n  ReceivedAgentTranscriptionMessage,\n} from '@livekit/components-core';\n\nimport { useAgent } from './useAgent';\nimport { useTranscriptions } from './useTranscriptions';\nimport { useChat } from './useChat';\nimport { UseSessionReturn } from './useSession';\nimport { useEnsureSession } from '../context';\n\n/** @beta */\nexport type UseSessionMessagesReturn = {\n  messages: Array<ReceivedMessage>;\n\n  /** Is a send operation currently in progress? */\n  isSending: boolean;\n\n  send: (message: string, options?: SendTextOptions) => Promise<ReceivedChatMessage>;\n\n  internal: {\n    emitter: TypedEventEmitter<MessagesCallbacks>;\n  };\n};\n\n/** @beta */\nexport enum MessagesEvent {\n  /**\n   * Emits when a new message is received from a participant\n   * args: (message: ReceivedMessage)\n   */\n  MessageReceived = 'messageReceived',\n}\n\n/** @beta */\nexport type MessagesCallbacks = {\n  [MessagesEvent.MessageReceived]: (message: ReceivedMessage) => void;\n};\n\n/** @beta */\nexport function useSessionMessages(session?: UseSessionReturn): UseSessionMessagesReturn {\n  const { room } = useEnsureSession(session);\n\n  const emitter = React.useMemo(\n    () => new EventEmitter() as TypedEventEmitter<MessagesCallbacks>,\n    [],\n  );\n\n  const agent = useAgent(session);\n\n  const transcriptions: Array<TextStreamData> = useTranscriptions({ room });\n  const chatOptions = React.useMemo(() => ({ room }), [room]);\n  const chat = useChat(chatOptions);\n\n  const transcriptionMessages: Array<\n    ReceivedUserTranscriptionMessage | ReceivedAgentTranscriptionMessage\n  > = React.useMemo(() => {\n    return transcriptions.map((transcription) => {\n      switch (transcription.participantInfo.identity) {\n        case room.localParticipant.identity:\n          return {\n            type: 'userTranscript',\n            message: transcription.text,\n\n            id: transcription.streamInfo.id,\n            timestamp: transcription.streamInfo.timestamp,\n            from: room.localParticipant,\n          };\n\n        case agent.internal.agentParticipant?.identity:\n        case agent.internal.workerParticipant?.identity:\n          return {\n            type: 'agentTranscript',\n            message: transcription.text,\n\n            id: transcription.streamInfo.id,\n            timestamp: transcription.streamInfo.timestamp,\n            from:\n              agent.internal.agentParticipant?.identity === transcription.participantInfo.identity\n                ? agent.internal.agentParticipant\n                : agent.internal.workerParticipant!,\n          };\n\n        default:\n          // FIXME: what should happen if an associated participant is not found?\n          //\n          // For now, just assume it is an agent transcription, since maybe it is from an agent\n          // which disconencted from the room or something like that.\n          return {\n            type: 'agentTranscript',\n            message: transcription.text,\n\n            id: transcription.streamInfo.id,\n            timestamp: transcription.streamInfo.timestamp,\n            from: Array.from(room.remoteParticipants.values()).find(\n              (p) => p.identity === transcription.participantInfo.identity,\n            ),\n          };\n      }\n    });\n  }, [transcriptions, room]);\n\n  const receivedMessages = React.useMemo(() => {\n    const merged: Array<ReceivedMessage> = [...transcriptionMessages, ...chat.chatMessages];\n    return merged;\n  }, [transcriptionMessages, chat.chatMessages]);\n\n  const messageFirstReceivedTimeMapRef = React.useRef(new Map<ReceivedMessage['id'], Date>());\n  const sortedReceivedMessages = React.useMemo(() => {\n    const now = new Date();\n    for (const message of receivedMessages) {\n      if (messageFirstReceivedTimeMapRef.current.has(message.id)) {\n        continue;\n      }\n\n      messageFirstReceivedTimeMapRef.current.set(message.id, now);\n    }\n\n    return receivedMessages.sort((a, b) => {\n      const aFirstReceivedAt = messageFirstReceivedTimeMapRef.current.get(a.id);\n      const bFirstReceivedAt = messageFirstReceivedTimeMapRef.current.get(b.id);\n      if (typeof aFirstReceivedAt === 'undefined' || typeof bFirstReceivedAt === 'undefined') {\n        return 0;\n      }\n\n      return aFirstReceivedAt.getTime() - bFirstReceivedAt.getTime();\n    });\n  }, [receivedMessages]);\n\n  const previouslyReceivedMessageIdsRef = React.useRef(new Set());\n  React.useEffect(() => {\n    for (const message of sortedReceivedMessages) {\n      if (previouslyReceivedMessageIdsRef.current.has(message.id)) {\n        continue;\n      }\n\n      previouslyReceivedMessageIdsRef.current.add(message.id);\n      emitter.emit(MessagesEvent.MessageReceived, message);\n    }\n  }, [sortedReceivedMessages]);\n\n  return React.useMemo(\n    () => ({\n      messages: sortedReceivedMessages,\n      send: chat.send,\n      isSending: chat.isSending,\n      internal: { emitter },\n    }),\n    [sortedReceivedMessages, chat.send, chat.isSending],\n  );\n}\n"],"names":["SessionContext","React","useSessionContext","ctx","useMaybeSessionContext","useEnsureSession","session","context","r","useAudioPlayback","room","roomEnsured","useEnsureRoom","startAudio","observable","roomAudioPlaybackAllowedObservable","canPlayAudio","useObservableState","useClearPinButton","props","state","dispatch","useLayoutContext","className","setupClearPinButton","mergeProps","useDataChannel","topicOrCallback","callback","onMessage","topic","useRoomContext","send","messageObservable","isSendingObservable","setupDataMessageHandler","message","isSending","defaultRoomProps","useLiveKitRoom","token","serverUrl","options","passedRoom","connectOptions","connect","audio","video","screen","onConnected","onDisconnected","onError","onMediaDeviceFailure","onEncryptionError","simulateParticipants","rest","log","setRoom","shouldConnect","Room","roomOptionsStringifyReplacer","htmlProps","setupLiveKitRoom","onSignalConnected","localP","e","handleMediaDeviceError","kind","mediaDeviceFailure","MediaDeviceFailure","handleEncryptionError","handleDisconnected","reason","handleConnected","RoomEvent","useParticipantInfo","p","useMaybeParticipantContext","infoObserver","participantInfoObserver","identity","name","metadata","useParticipantPermissions","useEnsureParticipant","permissionObserver","participantPermissionObserver","useRemoteParticipants","participants","setParticipants","listener","connectedParticipantsObserver","useParticipants","remoteParticipants","localParticipant","useLocalParticipant","useRemoteParticipant","identityOrIdentifier","updateOnlyOn","connectedParticipantObserver","participantByIdentifierObserver","participantWrapper","setParticipantWrapper","useRoomInfo","roomInfoObserver","useSpeakingParticipants","ensuredRoom","speakerObserver","activeSpeakerObserver","useSortedParticipants","sortedParticipants","setSortedParticipants","sortParticipants","activeSpeakers","useToken","tokenEndpoint","roomName","setToken","_a","params","res","accessToken","useTrackRefBySourceOrName","source","publication","setPublication","getTrackByIdentifier","trackObserver","setupMediaTrack","subscription","Track","useTrackByName","participant","useParticipantTracks","sources","optionsOrParticipantIdentity","participantIdentity","participantContext","participantTracksObservable","useTrackSyncTime","ref","trackSyncTimeObserver","_c","_b","TRACK_TRANSCRIPTION_DEFAULTS","useTrackTranscription","trackRef","opts","segments","setSegments","syncTimestamps","handleSegmentMessage","newSegments","prevSegments","dedupeSegments","s","addTimestampsToTranscription","trackTranscriptionObserver","evt","getTrackReferenceId","useParticipantAttributes","attributeObserver","participantAttributesObserver","useParticipantAttribute","attributeKey","attribute","setAttribute","val","state_attribute","ParticipantAgentAttributes","useVoiceAssistant","agent","ParticipantKind","worker","agentTracks","workerTracks","audioTrack","t","videoTrack","agentTranscriptions","connectionState","useConnectionState","attributes","ConnectionState","useIsRecording","recordingStatusObservable","useTextStream","isDisconnected","textStreamData","setupTextStream","textStreamObservable","useTranscriptions","participantIdentities","trackSids","textStreams","DataTopic","stream","CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY","CONNECT_DISCONNECT_WARNING_THRESHOLD_MS","ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY","ROOM_CHANGE_WARNING_THRESHOLD_MS","useSequentialRoomConnectDisconnect","connectDisconnectQueueRef","useRef","processConnectsAndDisconnectsLock","useMemo","Mutex","processConnectsAndDisconnects","useCallback","unlock","roomChangedTimesRef","checkRoomThreshold","now","roomChangesInThreshold","i","isWithinThreshold","useEffect","connectDisconnectEnqueueTimes","checkConnectDisconnectThreshold","connectDisconnectsInThreshold","args","resolve","reject","disconnect","R","ReflectApply","target","receiver","ReflectOwnKeys","ProcessEmitWarning","warning","NumberIsNaN","value","EventEmitter","eventsModule","once","defaultMaxListeners","checkListener","arg","n","_getMaxListeners","that","type","doError","events","er","err","handler","len","listeners","arrayClone","_addListener","prepend","m","existing","onceWrapper","_onceWrap","wrapped","list","position","originalListener","spliceOne","keys","key","_listeners","unwrap","evlistener","unwrapListeners","emitter","listenerCount","arr","copy","index","ret","errorListener","resolver","eventTargetAgnosticAddListener","addErrorHandlerIfEventEmitter","flags","wrapListener","DEFAULT_AGENT_CONNECT_TIMEOUT_MILLISECONDS","AgentEvent","generateDerivedStateValues","useAgentTimeoutIdStore","agentTimeoutFailureReason","setAgentTimeoutFailureReason","agentTimeoutId","setAgentTimeoutId","agentStateRef","agentParticipantExistsRef","startAgentConnectedTimeout","agentConnectTimeoutMilliseconds","isConnected","agentState","agentParticipantExists","useAgentWaitUntilDerivedStates","stateRef","waitUntilConnected","signal","stateChangedHandler","cleanup","abortHandler","waitUntilCouldBeListening","canListen","waitUntilFinished","isFinished","useAgent","sessionFromContext","startAgentTimeout","clearAgentTimeout","clearAgentTimeoutFailureReason","updateAgentTimeoutState","updateAgentTimeoutParticipantExists","roomRemoteParticipants","agentParticipant","workerParticipant","agentParticipantAttributes","setAgentParticipantAttributes","handleAttributesChanged","ParticipantEvent","roomConnectionState","setRoomConnectionState","handleConnectionStateChanged","agentDisconnectedFailureReason","setAgentDisconnectedFailureReason","onParticipantDisconnect","localMicTrack","setLocalMicTrack","handleLocalParticipantTrackPublished","handleLocalParticipantTrackUnPublished","failureReasons","reasons","isSessionDisconnected","common","waitUntilCamera","camera","waitUntilMicrophone","microphone","SessionEvent","areTokenSourceFetchOptionsEqual","a","b","allKeysSet","exhaustiveCheckedKey","useSessionWaitUntilConnectionState","connectionStateRef","onceEventOccurred","newState","useSessionTokenSourceFetch","tokenSource","unstableRestOptions","isConfigurable","TokenSourceConfigurable","memoizedTokenFetchOptionsRef","useSession","optionsRoom","restOptions","roomFromContext","useMaybeRoomContext","generateDerivedConnectionStateValues","handleMediaDevicesError","error","cameraPublication","localCamera","microphonePublication","localMicrophone","sessionInternal","conversationState","waitUntilConnectionState","waitUntilDisconnected","tokenSourceFetch","start","tracks","roomConnectOptions","onSignalAbort","tokenDispatchesAgent","participantToken","decodeTokenPayload","end","prepareConnection","credentials","useEvents","instance","event","handlerFn","dependencies","fallback","wrappedCallback","MessagesEvent","useSessionMessages","transcriptions","chatOptions","chat","useChat","transcriptionMessages","transcription","receivedMessages","messageFirstReceivedTimeMapRef","sortedReceivedMessages","aFirstReceivedAt","bFirstReceivedAt","previouslyReceivedMessageIdsRef"],"mappings":"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","x_google_ignoreList":[25]}